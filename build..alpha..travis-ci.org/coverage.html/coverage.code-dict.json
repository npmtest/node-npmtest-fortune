{"/home/travis/build/npmtest/node-npmtest-fortune/test.js":"/* istanbul instrument in package npmtest_fortune */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fortune/lib.npmtest_fortune.js":"/* istanbul instrument in package npmtest_fortune */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_fortune = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_fortune = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-fortune/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-fortune && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_fortune */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_fortune\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_fortune.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_fortune.rollup.js'] =\n            local.assetsDict['/assets.npmtest_fortune.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_fortune.__dirname +\n                    '/lib.npmtest_fortune.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/index.js":"'use strict'\n\nvar EventLite = require('event-lite')\n\n// Local modules.\nvar memoryAdapter = require('./adapter/adapters/memory')\nvar AdapterSingleton = require('./adapter/singleton')\nvar validate = require('./record_type/validate')\nvar ensureTypes = require('./record_type/ensure_types')\nvar dispatch = require('./dispatch')\nvar middlewares = dispatch.middlewares\n\n// Static re-exports.\nvar Adapter = require('./adapter')\nvar common = require('./common')\nvar assign = common.assign\nvar methods = common.methods\nvar events = common.events\n\n// Using this later to check for keys in Object.prototype.\nvar plainObject = {}\n\n\n/**\n * This is the default export of the `fortune` package. It implements a\n * [subset of `EventEmitter`](https://www.npmjs.com/package/event-lite), and it\n * has a few static properties attached to it that may be useful to access:\n *\n * - `Adapter`: abstract base class for the Adapter.\n * - `adapters`: included adapters, defaults to memory adapter.\n * - `errors`: custom error types, useful for throwing errors in I/O hooks.\n * - `methods`: a hash that maps to string constants. Available are: `find`,\n *   `create`, `update`, and `delete`.\n * - `events`: names for events on the Fortune instance. Available are:\n *   `change`, `sync`, `connect`, `disconnect`, `failure`.\n * - `message`: a function which accepts the arguments (`id`, `language`,\n *   `data`). It has properties keyed by two-letter language codes, which by\n *   default includes only `en`.\n */\nfunction Fortune (recordTypes, options) {\n  if (!(this instanceof Fortune))\n    return new Fortune(recordTypes, options)\n\n  this.constructor(recordTypes, options)\n}\n\n\n// Inherit from EventLite class.\nFortune.prototype = Object.create(EventLite.prototype)\n\n\n/**\n * Create a new instance, the only required input is record type definitions.\n * The first argument must be an object keyed by name, valued by definition\n * objects.\n *\n * Here are some example field definitions:\n *\n * ```js\n * {\n *   // Top level keys are names of record types.\n *   person: {\n *     // Data types may be singular or plural.\n *     name: String, // Singular string value.\n *     luckyNumbers: Array(Number), // Array of numbers.\n *\n *     // Relationships may be singular or plural. They must specify which\n *     // record type it refers to, and may also specify an inverse field\n *     // which is optional but recommended.\n *     pets: [ Array('animal'), 'owner' ], // Has many.\n *     employer: [ 'organization', 'employees' ], // Belongs to.\n *     likes: Array('thing'), // Has many (no inverse).\n *     doing: 'activity', // Belongs to (no inverse).\n *\n *     // Reflexive relationships are relationships in which the record type,\n *     // the first position, is of the same type.\n *     following: [ Array('person'), 'followers' ],\n *     followers: [ Array('person'), 'following' ],\n *\n *     // Mutual relationships are relationships in which the inverse,\n *     // the second position, is defined to be the same field on the same\n *     // record type.\n *     friends: [ Array('person'), 'friends' ],\n *     spouse: [ 'person', 'spouse' ]\n *   }\n * }\n * ```\n *\n * The above shows the shorthand which will be transformed internally to a\n * more verbose data structure. The internal structure is as follows:\n *\n * ```js\n * {\n *   person: {\n *     // A singular value.\n *     name: { type: String },\n *\n *     // An array containing values of a single type.\n *     luckyNumbers: { type: Number, isArray: true },\n *\n *     // Creates a to-many link to `animal` record type. If the field `owner`\n *     // on the `animal` record type is not an array, this is a many-to-one\n *     // relationship, otherwise it is many-to-many.\n *     pets: { link: 'animal', isArray: true, inverse: 'owner' },\n *\n *     // The `min` and `max` keys are open to interpretation by the specific\n *     // adapter, which may introspect the field definition.\n *     thing: { type: Number, min: 0, max: 100 },\n *\n *     // Nested field definitions are invalid. Use `Object` type instead.\n *     nested: { thing: { ... } } // Will throw an error.\n *   }\n * }\n * ```\n *\n * The allowed native types are `String`, `Number`, `Boolean`, `Date`,\n * `Object`, and `Buffer`. Note that the `Object` type should be a JSON\n * serializable object that may be persisted. The only other allowed type is\n * a `Function`, which may be used to define custom types.\n *\n * A custom type function should accept one argument, the value, and return a\n * boolean based on whether the value is valid for the type or not. It may\n * optionally have a method `compare`, used for sorting in the built-in\n * adapters. The `compare` method should have the same signature as the native\n * `Array.prototype.sort`.\n *\n * A custom type function must inherit one of the allowed native types. For\n * example:\n *\n * ```js\n * function Integer (x) { return (x | 0) === x }\n * Integer.prototype = Object.create(Number.prototype)\n * ```\n *\n * The options object may contain the following keys:\n *\n * - `adapter`: configuration array for the adapter. The default type is the\n *   memory adapter. If the value is not an array, its settings will be\n *   considered omitted.\n *\n *   ```js\n *   {\n *     adapter: [\n *       // Must be a class that extends `Fortune.Adapter`, or a function\n *       // that accepts the Adapter class and returns a subclass. Required.\n *       Adapter => { ... },\n *\n *       // An options object that is specific to the adapter. Optional.\n *       { ... }\n *     ]\n *   }\n *   ```\n *\n * - `hooks`: keyed by type name, valued by an array containing an `input`\n *   and/or `output` function at indices `0` and `1` respectively.\n *\n *   A hook function takes at least two arguments, the internal `context`\n *   object and a single `record`. A special case is the `update` argument for\n *   the `update` method.\n *\n *   There are only two kinds of hooks, before a record is written (input),\n *   and after a record is read (output), both are optional. If an error occurs\n *   within a hook function, it will be forwarded to the response. Use typed\n *   errors to provide the appropriate feedback.\n *\n *   For a create request, the input hook may return the second argument\n *   `record` either synchronously, or asynchronously as a Promise. The return\n *   value of a delete request is inconsequential, but it may return a value or\n *   a Promise. The `update` method accepts a `update` object as a third\n *   parameter, which may be returned synchronously or as a Promise.\n *\n *   An example hook to apply a timestamp on a record before creation, and\n *   displaying the timestamp in the server's locale:\n *\n *   ```js\n *   {\n *     recordType: [\n *       (context, record, update) => {\n *         switch (context.request.method) {\n *           case 'create':\n *             record.timestamp = new Date()\n *             return record\n *           case 'update': return update\n *           case 'delete': return null\n *         }\n *       },\n *       (context, record) => {\n *         record.timestamp = record.timestamp.toLocaleString()\n *         return record\n *       }\n *     ]\n *   }\n *   ```\n *\n *   Requests to update a record will **NOT** have the updates already applied\n *   to the record.\n *\n *   Another feature of the input hook is that it will have access to a\n *   temporary field `context.transaction`. This is useful for ensuring that\n *   bulk write operations are all or nothing. Each request is treated as a\n *   single transaction.\n *\n * - `documentation`: an object mapping names to descriptions. Note that there\n *   is only one namepspace, so field names can only have one description.\n *   This is optional, but useful for the HTML serializer, which also emits\n *   this information as micro-data.\n *\n *   ```js\n *   {\n *     documentation: {\n *       recordType: 'Description of a type.',\n *       fieldName: 'Description of a field.',\n *       anotherFieldName: {\n *         en: 'Two letter language code indicates localized description.'\n *       }\n *     }\n *   }\n *   ```\n *\n * - `settings`: internal settings to configure.\n *\n *   ```js\n *   {\n *     settings: {\n *       // Whether or not to enforce referential integrity. Default: `true`\n *       // for server, `false` for browser.\n *       enforceLinks: true,\n *\n *       // Name of the application used for display purposes.\n *       name: 'My Awesome Application',\n *\n *       // Description of the application used for display purposes.\n *       description: 'media type \"application/vnd.micro+json\"'\n *     }\n *   }\n *   ```\n *\n * The return value of the constructor is the instance itself.\n *\n * @param {Object} [recordTypes]\n * @param {Object} [options]\n * @return {Fortune}\n */\nFortune.prototype.constructor = function Fortune (recordTypes, options) {\n  var self = this\n  var adapter, method, stack, flows, type, hooks, i, j\n\n  if (recordTypes === void 0) recordTypes = {}\n  if (options === void 0) options = {}\n\n  if (!('adapter' in options)) options.adapter = [ memoryAdapter(Adapter) ]\n  if (!('settings' in options)) options.settings = {}\n  if (!('hooks' in options)) options.hooks = {}\n  if (!('enforceLinks' in options.settings))\n    options.settings.enforceLinks = true\n\n  // Bind middleware methods to instance.\n  flows = {}\n  for (method in methods) {\n    stack = [ middlewares[method], middlewares.include, middlewares.end ]\n\n    for (i = 0, j = stack.length; i < j; i++)\n      stack[i] = bindMiddleware(self, stack[i])\n\n    flows[methods[method]] = stack\n  }\n\n  hooks = options.hooks\n\n  // Validate hooks.\n  for (type in hooks) {\n    if (!recordTypes.hasOwnProperty(type)) throw new Error(\n      'Attempted to define hook on \"' + type + '\" type ' +\n      'which does not exist.')\n    if (!Array.isArray(hooks[type]))\n      throw new TypeError('Hook value for \"' + type + '\" type ' +\n        'must be an array.')\n  }\n\n  // Validate record types.\n  for (type in recordTypes) {\n    if (type in plainObject)\n      throw new Error('Can not define type name \"' + type +\n        '\" which is in Object.prototype.')\n\n    validate(recordTypes[type])\n    if (!hooks.hasOwnProperty(type)) hooks[type] = []\n  }\n\n  /*!\n   * Adapter singleton that is coupled to the Fortune instance.\n   *\n   * @type {Adapter}\n   */\n  adapter = new AdapterSingleton({\n    adapter: options.adapter,\n    recordTypes: recordTypes,\n    hooks: hooks\n  })\n\n  // Internal properties.\n  Object.defineProperties(self, {\n    // 0 = not started, 1 = started, 2 = done.\n    connectionStatus: { value: 0, writable: true },\n\n    // Configuration settings.\n    options: { value: options },\n    hooks: { value: hooks },\n    recordTypes: { value: recordTypes, enumerable: true },\n\n    // Singleton instances.\n    adapter: { value: adapter, enumerable: true, configurable: true },\n\n    // Dispatch.\n    flows: { value: flows }\n  })\n}\n\n\n/**\n * This is the primary method for initiating a request. The options object\n * may contain the following keys:\n *\n * - `method`: The method is a either a function or a constant, which is keyed\n *   under `Fortune.common.methods` and may be one of `find`, `create`,\n *   `update`, or `delete`. Default: `find`.\n *\n * - `type`: Name of a type. **Required**.\n *\n * - `ids`: An array of IDs. Used for `find` and `delete` methods only. This is\n *   optional for the `find` method.\n *\n * - `include`: A 2-dimensional array specifying links to include. The first\n *   dimension is a list, the second dimension is depth. For example:\n *   `[['comments'], ['comments', 'author', { ... }]]`. The last item within\n *   the list may be an `options` object, useful for specifying how the\n *   included records should appear. Optional.\n *\n * - `options`: Exactly the same as the [`find` method](#adapter-find)\n *   options in the adapter. These options do not apply on methods other than\n *   `find`, and do not affect the records returned from `include`. Optional.\n *\n * - `meta`: Meta-information object of the request. Optional.\n *\n * - `payload`: Payload of the request. **Required** for `create` and `update`\n *   methods only, and must be an array of objects. The objects must be the\n *   records to create, or update objects as expected by the Adapter.\n *\n * The response object may contain the following keys:\n *\n * - `meta`: Meta-info of the response.\n *\n * - `payload`: An object containing the following keys:\n *   - `records`: An array of records returned.\n *   - `count`: Total number of records without options applied (only for\n *     responses to the `find` method).\n *   - `include`: An object keyed by type, valued by arrays of included\n *     records.\n *\n * The resolved response object should always be an instance of a response\n * type.\n *\n * @param {Object} options\n * @return {Promise}\n */\nFortune.prototype.request = function (options) {\n  var self = this\n  var connectionStatus = self.connectionStatus\n\n  if (connectionStatus === 0)\n    return self.connect()\n    .then(function () { return dispatch(self, options) })\n\n  else if (connectionStatus === 1)\n    return new Promise(function (resolve, reject) {\n      // Wait for changes to connection status.\n      self.once(events.failure, function () {\n        reject(new Error('Connection failed.'))\n      })\n      self.once(events.connect, function () {\n        resolve(dispatch(self, options))\n      })\n    })\n\n  return dispatch(self, options)\n}\n\n\n/**\n * The `find` method retrieves record by type given IDs, querying options,\n * or both. This is a convenience method that wraps around the `request`\n * method, see the `request` method for documentation on its arguments.\n *\n * @param {String} type\n * @param {*|*[]} [ids]\n * @param {Object} [options]\n * @param {Array[]} [include]\n * @param {Object} [meta]\n * @return {Promise}\n */\nFortune.prototype.find = function () {\n  var options = { method: methods.find, type: arguments[0] }\n\n  if (arguments[1] != null) options.ids = Array.isArray(arguments[1]) ?\n    arguments[1] : [ arguments[1] ]\n  if (arguments[2] != null) options.options = arguments[2]\n  if (arguments[3] != null) options.include = arguments[3]\n  if (arguments[4] != null) options.meta = arguments[4]\n\n  return this.request(options)\n}\n\n\n/**\n * The `create` method creates records by type given records to create. This\n * is a convenience method that wraps around the `request` method, see the\n * request `method` for documentation on its arguments.\n *\n * @param {String} type\n * @param {Object|Object[]} records\n * @param {Array[]} [include]\n * @param {Object} [meta]\n * @return {Promise}\n */\nFortune.prototype.create = function () {\n  var options = { method: methods.create, type: arguments[0],\n    payload: Array.isArray(arguments[1]) ? arguments[1] : [ arguments[1] ] }\n\n  if (arguments[2] != null) options.include = arguments[2]\n  if (arguments[3] != null) options.meta = arguments[3]\n\n  return this.request(options)\n}\n\n\n/**\n * The `update` method updates records by type given update objects. See the\n * [Adapter.update](#adapter-update) method for the format of the update\n * objects. This is a convenience method that wraps around the `request`\n * method, see the `request` method for documentation on its arguments.\n *\n * @param {String} type\n * @param {Object|Object[]} updates\n * @param {Array[]} [include]\n * @param {Object} [meta]\n * @return {Promise}\n */\nFortune.prototype.update = function () {\n  var options = { method: methods.update, type: arguments[0],\n    payload: Array.isArray(arguments[1]) ? arguments[1] : [ arguments[1] ] }\n\n  if (arguments[2] != null) options.include = arguments[2]\n  if (arguments[3] != null) options.meta = arguments[3]\n\n  return this.request(options)\n}\n\n\n/**\n * The `delete` method deletes records by type given IDs (optional). This is a\n * convenience method that wraps around the `request` method, see the `request`\n * method for documentation on its arguments.\n *\n * @param {String} type\n * @param {*|*[]} [ids]\n * @param {Array[]} [include]\n * @param {Object} [meta]\n * @return {Promise}\n */\nFortune.prototype.delete = function () {\n  var options = { method: methods.delete, type: arguments[0] }\n\n  if (arguments[1] != null) options.ids = Array.isArray(arguments[1]) ?\n    arguments[1] : [ arguments[1] ]\n  if (arguments[2] != null) options.include = arguments[2]\n  if (arguments[3] != null) options.meta = arguments[3]\n\n  return this.request(options)\n}\n\n\n/**\n * This method does not need to be called manually, it is automatically called\n * upon the first request if it is not connected already. However, it may be\n * useful if manually reconnect is needed. The resolved value is the instance\n * itself.\n *\n * @return {Promise}\n */\nFortune.prototype.connect = function () {\n  var self = this\n\n  if (self.connectionStatus === 1)\n    return Promise.reject(new Error('Connection is in progress.'))\n\n  else if (self.connectionStatus === 2)\n    return Promise.reject(new Error('Connection is already done.'))\n\n  self.connectionStatus = 1\n\n  return new Promise(function (resolve, reject) {\n    ensureTypes(self.recordTypes)\n\n    self.adapter.connect().then(function () {\n      self.connectionStatus = 2\n      self.emit(events.connect)\n      return resolve(self)\n    }, function (error) {\n      self.connectionStatus = 0\n      self.emit(events.failure)\n      return reject(error)\n    })\n  })\n}\n\n\n/**\n * Close adapter connection, and reset connection state. The resolved value is\n * the instance itself.\n *\n * @return {Promise}\n */\nFortune.prototype.disconnect = function () {\n  var self = this\n\n  if (self.connectionStatus !== 2)\n    return Promise.reject(new Error('Instance has not been connected.'))\n\n  self.connectionStatus = 1\n\n  return new Promise(function (resolve, reject) {\n    return self.adapter.disconnect().then(function () {\n      self.connectionStatus = 0\n      self.emit(events.disconnect)\n      return resolve(self)\n    }, function (error) {\n      self.connectionStatus = 2\n      self.emit(events.failure)\n      return reject(error)\n    })\n  })\n}\n\n\n// Useful for dependency injection. All instances of Fortune have the same\n// common internal dependencies.\nFortune.prototype.common = common\n\n\n// Assign useful static properties to the default export.\nassign(Fortune, {\n  Adapter: Adapter,\n  adapters: {\n    memory: memoryAdapter(Adapter)\n  },\n  errors: common.errors,\n  message: common.message,\n  methods: methods,\n  events: events\n})\n\n\n// Internal helper function.\nfunction bindMiddleware (scope, method) {\n  return function (x) {\n    return method.call(scope, x)\n  }\n}\n\n\nmodule.exports = Fortune\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/adapter/adapters/memory/index.js":"'use strict'\n\nvar applyUpdate = require('../../../common/apply_update')\nvar map = require('../../../common/array/map')\n\nvar common = require('../common')\nvar applyOptions = common.applyOptions\n\nvar helpers = require('./helpers')\nvar inputRecord = helpers.inputRecord\nvar outputRecord = helpers.outputRecord\n\n\n/**\n * Memory adapter.\n */\nmodule.exports = function (Adapter) {\n  function MemoryAdapter (properties) {\n    Adapter.call(this, properties)\n    if (!this.options) this.options = {}\n    if (!('recordsPerType' in this.options))\n      this.options.recordsPerType = 1000\n  }\n\n  MemoryAdapter.prototype = Object.create(Adapter.prototype)\n\n  MemoryAdapter.prototype.connect = function () {\n    var recordTypes = this.recordTypes\n    var type\n\n    this.db = {}\n\n    for (type in recordTypes)\n      this.db[type] = {}\n\n    return Promise.resolve()\n  }\n\n\n  MemoryAdapter.prototype.disconnect = function () {\n    delete this.db\n    return Promise.resolve()\n  }\n\n\n  MemoryAdapter.prototype.find = function (type, ids, options, meta) {\n    var self = this\n    var recordTypes = self.recordTypes\n    var fields = recordTypes[type]\n    var collection = self.db[type]\n    var records = []\n    var i, j, id, record\n\n    if (ids && !ids.length) return Adapter.prototype.find.call(self)\n\n    if (ids) for (i = 0, j = ids.length; i < j; i++) {\n      id = ids[i]\n      if (collection.hasOwnProperty(id)) {\n        record = collection[id]\n\n        // LRU update.\n        delete collection[id]\n        collection[id] = record\n\n        records.push(outputRecord.call(self, type, record))\n      }\n    }\n\n    else for (id in collection)\n      records.push(outputRecord.call(self, type, collection[id]))\n\n    return Promise.resolve(applyOptions(fields, records, options, meta))\n  }\n\n\n  MemoryAdapter.prototype.create = function (type, records, meta) {\n    var self = this\n    var message = self.message\n    var recordsPerType = self.options.recordsPerType\n    var primaryKey = self.keys.primary\n    var ConflictError = self.errors.ConflictError\n    var collection = self.db[type]\n    var i, j, record, id, ids, language\n\n    if (!meta) meta = {}\n    language = meta.language\n\n    records = map(records, function (record) {\n      return inputRecord.call(self, type, record)\n    })\n\n    // First check for collisions.\n    for (i = 0, j = records.length; i < j; i++) {\n      record = records[i]\n      id = record[primaryKey]\n\n      if (collection.hasOwnProperty(id))\n        return Promise.reject(new ConflictError(\n          message('RecordExists', language, { id: id })))\n    }\n\n    // Then save it to memory.\n    for (i = 0, j = records.length; i < j; i++) {\n      record = records[i]\n      collection[record[primaryKey]] = record\n    }\n\n    // Clear least recently used records.\n    if (recordsPerType) {\n      ids = Object.keys(collection)\n\n      if (ids.length > recordsPerType) {\n        ids = ids.slice(0, ids.length - recordsPerType)\n\n        for (i = 0, j = ids.length; i < j; i++)\n          delete collection[ids[i]]\n      }\n    }\n\n    return Promise.resolve(map(records, function (record) {\n      return outputRecord.call(self, type, record)\n    }))\n  }\n\n\n  MemoryAdapter.prototype.update = function (type, updates) {\n    var self = this\n    var primaryKey = self.keys.primary\n    var collection = self.db[type]\n    var count = 0\n    var i, j, update, id, record\n\n    if (!updates.length) return Adapter.prototype.update.call(self)\n\n    for (i = 0, j = updates.length; i < j; i++) {\n      update = updates[i]\n      id = update[primaryKey]\n      record = collection[id]\n\n      if (!record) continue\n\n      count++\n      record = outputRecord.call(self, type, record)\n\n      applyUpdate(record, update)\n\n      // LRU update.\n      delete collection[id]\n\n      collection[id] = inputRecord.call(self, type, record)\n    }\n\n    return Promise.resolve(count)\n  }\n\n\n  MemoryAdapter.prototype.delete = function (type, ids) {\n    var collection = this.db[type]\n    var count = 0\n    var i, j, id\n\n    if (ids && !ids.length) return Adapter.prototype.delete.call(this)\n\n    if (ids) for (i = 0, j = ids.length; i < j; i++) {\n      id = ids[i]\n      if (collection[id]) {\n        delete collection[id]\n        count++\n      }\n    }\n\n    else for (id in collection) {\n      delete collection[id]\n      count++\n    }\n\n    return Promise.resolve(count)\n  }\n\n  // Expose utility functions.\n  MemoryAdapter.common = common\n\n  // Expose features.\n  MemoryAdapter.features = {\n    logicalOperators: true\n  }\n\n  return MemoryAdapter\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/apply_update.js":"'use strict'\n\nvar pull = require('./array/pull')\n\n\n/**\n * Given a record and an update object, apply the update on the record. Note\n * that the `operate` object is unapplied here.\n *\n * @param {Object} record\n * @param {Object} update\n */\nmodule.exports = function applyUpdate (record, update) {\n  var field\n\n  for (field in update.replace)\n    record[field] = update.replace[field]\n\n  for (field in update.push)\n    record[field] = record[field] ?\n      record[field].concat(update.push[field]) :\n      [].concat(update.push[field])\n\n  for (field in update.pull)\n    record[field] = record[field] ?\n      pull(record[field], update.pull[field]) : []\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/array/pull.js":"'use strict'\n\n\n/**\n * Pull primitive values from an array.\n *\n * @param {*[]} array\n * @param {*|*[]} values\n * @return {*[]}\n */\nmodule.exports = function pull (array, values) {\n  var hash = {}, clone = [], value\n  var i, j\n\n  if (Array.isArray(values))\n    for (i = 0, j = values.length; i < j; i++)\n      hash[values[i]] = true\n  else hash[values] = true\n\n  // Need to iterate backwards.\n  for (i = array.length; i--;) {\n    value = array[i]\n    if (!hash.hasOwnProperty(value)) clone.push(value)\n  }\n\n  return clone\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/array/map.js":"'use strict'\n\n/**\n * A more performant `Array.prototype.map`.\n *\n * @param {*[]} array\n * @param {Function} fn\n * @return {Boolean}\n */\nmodule.exports = function map (array, fn) {\n  var i, j, k = [], l = 0\n\n  for (i = 0, j = array.length; i < j; i++)\n    k[l++] = fn(array[i], i, array)\n\n  return k\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/adapter/adapters/common.js":"'use strict'\n\nvar deepEqual = require('../../common/deep_equal')\nvar message = require('../../common/message')\nvar find = require('../../common/array/find')\nvar generateId = require('../../common/generate_id')\n\nvar errors = require('../../common/errors')\nvar BadRequestError = errors.BadRequestError\n\nvar keys = require('../../common/keys')\nvar primaryKey = keys.primary\nvar typeKey = keys.type\nvar isArrayKey = keys.isArray\n\n// For complex types.\nvar matchCheck = [\n  [ Date, function (a, b) { return a.getTime() === b.getTime() } ],\n  [ Buffer, function (a, b) { return a.equals(b) } ],\n  [ Object, function (a, b) { return deepEqual(a, b) } ]\n]\n\n// For comparing sort order.\nvar comparisons = [\n  [ Number, function (a, b) { return a - b } ],\n  [ String, function (a, b) { return a === b ? 0 : a > b ? 1 : -1 } ],\n  [ Boolean, function (a, b) { return a === b ? 0 : a ? 1 : -1 } ],\n  [ Date, function (a, b) { return a.getTime() - b.getTime() } ],\n  [ Buffer, Buffer.compare ],\n\n  // There is no comparison here that makes sense, so this should simply be a\n  // no-op by default.\n  [ Object, function () { return 0 } ]\n]\n\n\n// Browser-safe ID generation.\nexports.generateId = generateId\n\n\nexports.applyOptions = function (fields, records, options, meta) {\n  var count, record, field, isInclude, isExclude, language, memoizedRecords\n  var i, j\n\n  if (!options) options = {}\n  if (!meta) meta = {}\n\n  language = meta.language\n\n  // Apply filters.\n  if (options) {\n    memoizedRecords = records\n    records = []\n    for (i = 0, j = memoizedRecords.length; i < j; i++) {\n      record = memoizedRecords[i]\n      if (match(fields, options, record))\n        records.push(record)\n    }\n  }\n\n  count = records.length\n\n  if ('fields' in options) {\n    isInclude = !find(Object.keys(options.fields),\n      function (field) { return !options.fields[field] })\n    isExclude = !find(Object.keys(options.fields),\n      function (field) { return options.fields[field] })\n\n    if (!isInclude && !isExclude)\n      throw new BadRequestError(message('FieldsFormat', language))\n\n    for (i = 0, j = records.length; i < j; i++) {\n      record = records[i]\n      for (field in record) {\n        if (field === primaryKey) continue\n        if ((isInclude && !(options.fields.hasOwnProperty(field))) ||\n          (isExclude && options.fields.hasOwnProperty(field)))\n          delete record[field]\n      }\n    }\n  }\n\n  if ('sort' in options)\n    records = records.sort(compare(fields, options.sort))\n\n  if ('limit' in options || 'offset' in options)\n    records = records.slice(options.offset, options.limit ?\n      (options.offset || 0) + options.limit : records.length)\n\n  records.count = count\n\n  return records\n}\n\n\nfunction check (type, a, b) {\n  var matcher\n\n  if (b === null) return a === null\n  if (!type) return a === b\n  if (type.compare) return type.compare(a, b) === 0\n\n  matcher = find(matchCheck, function (pair) {\n    return pair[0] === type.prototype.constructor\n  })\n  if (matcher) return matcher[1](a, b)\n\n  return a === b\n}\n\n\nfunction checkValue (fieldDefinition, a) {\n  return function (b) {\n    return fieldDefinition[isArrayKey] ?\n      find(a, function (a) {\n        return check(fieldDefinition[typeKey], b, a)\n      }) : check(fieldDefinition[typeKey], b, a)\n  }\n}\n\nfunction match (fields, options, record) {\n  var key\n\n  for (key in options)\n    switch (key) {\n    case 'and':\n      if (!matchByLogicalAnd(fields, options[key], record)) return false\n      break\n    case 'or':\n      if (!matchByLogicalOr(fields, options[key], record)) return false\n      break\n    case 'not':\n      if (match(fields, options[key], record)) return false\n      break\n    case 'range':\n      if (!matchByRange(fields, options[key], record)) return false\n      break\n    case 'match':\n      if (!matchByField(fields, options[key], record)) return false\n      break\n    case 'exists':\n      if (!matchByExistence(fields, options[key], record)) return false\n      break\n    default:\n    }\n\n  return true\n}\n\nfunction matchByLogicalAnd (fields, clauses, record) {\n  var i\n\n  for (i = 0; i < clauses.length; i++)\n    if (!match(fields, clauses[i], record)) return false\n\n  return true\n}\n\nfunction matchByLogicalOr (fields, clauses, record) {\n  var i\n\n  for (i = 0; i < clauses.length; i++)\n    if (match(fields, clauses[i], record)) return true\n\n  return false\n}\n\nfunction matchByField (fields, match, record) {\n  var field, matches\n\n  for (field in match) {\n    matches = match[field]\n    if (!Array.isArray(matches)) matches = [ matches ]\n    if (find(matches, checkValue(fields[field], record[field])) === void 0)\n      return false\n  }\n\n  return true\n}\n\n\nfunction matchByExistence (fields, exists, record) {\n  var field, value, isArray\n\n  for (field in exists) {\n    value = record[field]\n    isArray = fields[field][isArrayKey]\n    if (exists[field]) {\n      if (!value) return false\n      if (isArray && !value.length) return false\n    }\n    else {\n      if (value && !isArray) return false\n      if (isArray && value.length) return false\n    }\n  }\n\n  return true\n}\n\n\nfunction matchByRange (fields, ranges, record) {\n  var compare = {}\n  var field, fieldDefinition, fieldType, fieldIsArray, range, value\n\n  for (field in ranges) {\n    fieldDefinition = fields[field]\n    fieldType = fieldDefinition[typeKey]\n    fieldIsArray = fieldDefinition[isArrayKey]\n\n    // Skip for singular link fields.\n    if (!fieldType && !fieldIsArray) continue\n\n    range = ranges[field]\n    value = record[field]\n\n    if (value == null) return false\n    if (fieldIsArray) value = value ? value.length : 0\n\n    if (!compare[field])\n      compare[field] = !fieldIsArray ? fieldType.compare ||\n        find(comparisons, findByType(fieldType))[1] :\n        find(comparisons, findByType(Number))[1]\n\n    if (range[0] !== null && compare[field](value, range[0]) < 0)\n      return false\n\n    if (range[1] !== null && compare[field](range[1], value) < 0)\n      return false\n  }\n\n  return true\n}\n\n\nfunction findByType (type) {\n  return function (pair) {\n    return pair[0] === type.prototype.constructor\n  }\n}\n\n\nfunction compare (fields, sort) {\n  var field, compare, a, b, isAscending,\n    fieldDefinition, fieldIsArray, fieldType, result\n\n  return function (x, y) {\n    for (field in sort) {\n      a = x[field]\n      b = y[field]\n      isAscending = sort[field]\n      fieldDefinition = fields[field]\n      fieldIsArray = fieldDefinition[isArrayKey]\n      fieldType = fieldDefinition[typeKey]\n\n      if (a === null) return 1\n      if (b === null) return -1\n\n      result = 0\n\n      if (fieldIsArray) result = a.length - b.length\n      else if (fieldType) {\n        compare = fieldType.compare ||\n          find(comparisons, findByType(fieldType))[1]\n        if (!compare) throw new Error('Missing \"compare\" function.')\n        result = compare(a, b)\n      }\n\n      if (result === 0) continue\n\n      return isAscending ? result : -result\n    }\n\n    return 0\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/deep_equal.js":"'use strict'\n\n/**\n * A fast recursive equality check, which covers limited use cases.\n *\n * @param {Object}\n * @param {Object}\n * @return {Boolean}\n */\nfunction deepEqual (a, b) {\n  var key, value, compare, aLength = 0, bLength = 0\n\n  // If they are the same object, don't need to go further.\n  if (a === b) return true\n\n  // Both objects must be defined.\n  if (!a || !b) return false\n\n  // Objects must be of the same type.\n  if (a.prototype !== b.prototype) return false\n\n  for (key in a) {\n    aLength++\n    value = a[key]\n    compare = b[key]\n\n    if (typeof value === 'object') {\n      if (typeof compare !== 'object' || !deepEqual(value, compare))\n        return false\n      continue\n    }\n\n    if (Buffer.isBuffer(value)) {\n      if (!Buffer.isBuffer(compare) || !value.equals(compare))\n        return false\n      continue\n    }\n\n    if (value && typeof value.getTime === 'function') {\n      if (!compare || typeof compare.getTime !== 'function' ||\n        value.getTime() !== compare.getTime())\n        return false\n      continue\n    }\n\n    if (value !== compare) return false\n  }\n\n  for (key in b) bLength++\n\n  // Keys must be of same length.\n  return aLength === bLength\n}\n\n\nmodule.exports = deepEqual\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/message.js":"'use strict'\n\nvar genericMessage = 'GenericError'\n\nmodule.exports = message\n\n\n/**\n * Message function for i18n.\n *\n * @param {String} id\n * @param {String} language\n * @param {Object} [data]\n * @return {String}\n */\nfunction message (id, language, data) {\n  var str, key, subtag\n\n  if (!message.hasOwnProperty(language)) {\n    subtag = language && language.match(/.+?(?=-)/)\n    if (subtag) subtag = subtag[0]\n    if (message.hasOwnProperty(subtag)) language = subtag\n    else language = message.defaultLanguage\n  }\n\n  if (!message[language].hasOwnProperty(id))\n    return message[language][genericMessage] || message.en[genericMessage]\n\n  str = message[language][id]\n\n  for (key in data) str = str.replace('{' + key + '}', data[key])\n\n  return str\n}\n\n// Assign fallback language to \"en\".\nObject.defineProperty(message, 'defaultLanguage', {\n  value: 'en', writable: true\n})\n\n// Default language messages.\n/* eslint-disable max-len */\nmessage.en = {\n  'GenericError': 'An internal error occurred.',\n\n   // Various errors.\n  'MalformedRequest': 'The request was malformed.',\n  'InvalidBody': 'The request body is invalid.',\n  'SerializerNotFound': 'The serializer for \"{id}\" does not exist.',\n  'InputOnly': 'Input only.',\n  'InvalidID': 'An ID is invalid.',\n  'DateISO8601': 'Date string must be an ISO 8601 formatted string.',\n  'DateInvalid': 'Date value is invalid.',\n  'BufferEncoding': 'Buffer value must be a {bufferEncoding}-encoded string.',\n  'JSONParse': 'Could not parse value as JSON.',\n  'MissingPayload': 'Payload is missing.',\n  'SpecifiedIDs': 'IDs should not be specified.',\n  'InvalidURL': 'Invalid URL.',\n  'RelatedRecordNotFound': 'A related record for the field \"{field}\" was not found.',\n  'CreateRecordsInvalid': 'There are no valid records to be created.',\n  'CreateRecordsFail': 'Records could not be created.',\n  'CreateRecordMissingID': 'An ID on a created record is missing.',\n  'DeleteRecordsMissingID': 'IDs are required for deleting records.',\n  'DeleteRecordsInvalid': 'A record to be deleted could not be found.',\n  'DeleteRecordsFail': 'Not all records specified could be deleted.',\n  'UnspecifiedType': 'The type is unspecified.',\n  'InvalidType': 'The requested type \"{type}\" is not a valid type.',\n  'InvalidMethod': 'The method \"{method}\" is unrecognized.',\n  'CollisionToOne': 'Multiple records can not have the same to-one link value on the field \"{field}\".',\n  'CollisionDuplicate': 'Duplicate ID \"{id}\" in the field \"{field}\".',\n  'UpdateRecordMissing': 'A record to be updated could not be found.',\n  'UpdateRecordsInvalid': 'There are no valid updates.',\n  'UpdateRecordMissingID': 'An ID on an update is missing.',\n  'EnforceArrayType': 'The value of \"{key}\" is invalid, it must be an array with values of type \"{type}\".',\n  'EnforceArray': 'The value of \"{key}\" is invalid, it must be an array.',\n  'EnforceSameID': 'An ID of \"{key}\" is invalid, it cannot be the same ID of the record.',\n  'EnforceSingular': 'The value of \"{key}\" can not be an array, it must be a singular value.',\n  'EnforceValue': 'The value of \"{key}\" is invalid, it must be a \"{type}\".',\n  'EnforceValueArray': 'A value in the array of \"{key}\" is invalid, it must be a \"{type}\".',\n  'FieldsFormat': 'Fields format is invalid. It may either be inclusive or exclusive, but not both.',\n  'RecordExists': 'A record with ID \"{id}\" already exists.',\n\n  // Used for HTML serializer.\n  'Index': 'Index',\n  'Class': 'Class',\n  'Properties': 'Properties',\n  'Include': 'Include',\n  'QueryOptions': 'Query Options',\n  'IncludedLabel': 'included',\n  'NoResults': 'No results.',\n  'Create': 'Create',\n  'Update': 'Update',\n  'Delete': 'Delete',\n  'True': 'True',\n  'False': 'False',\n  'IncludePath': 'Path (dot-separated)',\n  'Query': 'Query',\n  'Fields': 'Fields',\n  'Match': 'Match',\n  'Sort': 'Sort',\n  'Field': 'Field',\n  'Pagination': 'Pagination',\n  'Limit': 'Limit',\n  'Offset': 'Offset'\n}\n/* eslint-enable max-len */\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/array/find.js":"'use strict'\n\n/**\n * A more performant `Array.prototype.find`.\n *\n * @param {*[]} array\n * @param {Function} fn\n * @return {*}\n */\nmodule.exports = function find (array, fn) {\n  var i, j, value, result\n\n  for (i = 0, j = array.length; i < j; i++) {\n    value = array[i]\n    result = fn(value)\n    if (result) return value\n  }\n\n  return void 0\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/generate_id.js":"'use strict'\n\nmodule.exports = function generateId () {\n  return Date.now() + '-' +\n    ('00000000' + Math.floor(Math.random() * Math.pow(2, 32)).toString(16))\n    .slice(-8)\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/errors.js":"'use strict'\n\nvar responseClass = require('./response_classes')\n\nexports.BadRequestError = responseClass.BadRequestError\nexports.UnauthorizedError = responseClass.UnauthorizedError\nexports.ForbiddenError = responseClass.ForbiddenError\nexports.NotFoundError = responseClass.NotFoundError\nexports.MethodError = responseClass.MethodError\nexports.NotAcceptableError = responseClass.NotAcceptableError\nexports.ConflictError = responseClass.ConflictError\nexports.UnsupportedError = responseClass.UnsupportedError\nexports.nativeErrors = responseClass.nativeErrors\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/response_classes.js":"'use strict'\n\nvar errorClass = require('error-class')\nvar assign = require('./assign')\n\n\n// Successes.\nexports.OK = successClass('OK')\nexports.Created = successClass('Created')\nexports.Empty = successClass('Empty')\n\n\n// Errors.\nexports.BadRequestError = errorClass('BadRequestError')\nexports.UnauthorizedError = errorClass('UnauthorizedError')\nexports.ForbiddenError = errorClass('ForbiddenError')\nexports.NotFoundError = errorClass('NotFoundError')\nexports.MethodError = errorClass('MethodError')\nexports.NotAcceptableError = errorClass('NotAcceptableError')\nexports.ConflictError = errorClass('ConflictError')\nexports.UnsupportedError = errorClass('UnsupportedError')\n\n\n// White-list native error types. The list is gathered from here:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/\n// Reference/Global_Objects/Error\nexports.nativeErrors = [\n  Error, TypeError, ReferenceError, RangeError,\n  SyntaxError, EvalError, URIError\n]\n\n\nfunction successClass (name) {\n  return Function('assign', // eslint-disable-line\n    'return function ' + name + ' (x) { ' +\n    'assign(this, x) }')(assign)\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/assign.js":"'use strict'\n\n/**\n * Like `Object.assign`, but faster and more restricted in what it does.\n *\n * @param {Object} target\n * @return {Object}\n */\nmodule.exports = function assign (target) {\n  var i, j, key, source\n\n  for (i = 1, j = arguments.length; i < j; i++) {\n    source = arguments[i]\n\n    if (source == null) continue\n\n    for (key in source)\n      target[key] = source[key]\n  }\n\n  return target\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/keys.js":"'use strict'\n\nvar constants = require('./constants')\n\nexports.primary = constants.primary\nexports.type = constants.type\nexports.link = constants.link\nexports.isArray = constants.isArray\nexports.inverse = constants.inverse\nexports.denormalizedInverse = constants.denormalizedInverse\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/constants.js":"'use strict'\n\n// The primary key that must exist per record, can not be user defined.\nexports.primary = 'id'\n\n// The names of certain reserved keys per field definition.\nexports.type = 'type'\nexports.link = 'link'\nexports.inverse = 'inverse'\nexports.isArray = 'isArray'\n\n// Should be reserved for private use.\nexports.denormalizedInverse = '__denormalizedInverse__'\n\n// Events.\nexports.change = 'change'\nexports.sync = 'sync'\nexports.connect = 'connect'\nexports.disconnect = 'disconnect'\nexports.failure = 'failure'\n\n// Methods.\nexports.find = 'find'\nexports.create = 'create'\nexports.update = 'update'\nexports.delete = 'delete'\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/adapter/adapters/memory/helpers.js":"'use strict'\n\nvar common = require('../common')\nvar generateId = common.generateId\n\n\nexports.inputRecord = function (type, record) {\n  var recordTypes = this.recordTypes\n  var primaryKey = this.keys.primary\n  var isArrayKey = this.keys.isArray\n  var fields = recordTypes[type]\n  var fieldsArray = Object.getOwnPropertyNames(fields)\n  var result = {}\n  var i, j, field\n\n  // ID business.\n  result[primaryKey] = primaryKey in record ?\n    record[primaryKey] : generateId()\n\n  for (i = 0, j = fieldsArray.length; i < j; i++) {\n    field = fieldsArray[i]\n    if (!record.hasOwnProperty(field)) {\n      result[field] = fields[field][isArrayKey] ? [] : null\n      continue\n    }\n\n    result[field] = record[field]\n  }\n\n  return result\n}\n\n\nexports.outputRecord = function (type, record) {\n  var recordTypes = this.recordTypes\n  var primaryKey = this.keys.primary\n  var isArrayKey = this.keys.isArray\n  var denormalizedInverseKey = this.keys.denormalizedInverse\n  var fields = recordTypes[type]\n  var fieldsArray = Object.getOwnPropertyNames(fields)\n  var result = {}\n  var i, j, field, hasField, value\n\n  // ID business.\n  result[primaryKey] = record[primaryKey]\n\n  for (i = 0, j = fieldsArray.length; i < j; i++) {\n    field = fieldsArray[i]\n    hasField = record.hasOwnProperty(field)\n    value = hasField ? record[field] :\n      fields[field][isArrayKey] ? [] : null\n\n    // Do not enumerate denormalized fields.\n    if (fields[field][denormalizedInverseKey]) {\n      Object.defineProperty(result, field, {\n        configurable: true, writable: true, value: value\n      })\n      continue\n    }\n\n    if (hasField) result[field] = value\n  }\n\n  return result\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/adapter/singleton.js":"'use strict'\n\nvar Adapter = require('./')\nvar common = require('../common')\nvar errors = require('../common/errors')\nvar keys = require('../common/keys')\nvar message = require('../common/message')\n\n\n/**\n * A singleton for the adapter. For internal use.\n */\nfunction AdapterSingleton (properties) {\n  var CustomAdapter, input\n\n  input = Array.isArray(properties.adapter) ?\n    properties.adapter : [ properties.adapter ]\n\n  if (typeof input[0] !== 'function')\n    throw new TypeError('The adapter must be a function.')\n\n  CustomAdapter = Adapter.prototype\n    .isPrototypeOf(input[0].prototype) ? input[0] : input[0](Adapter)\n\n  if (!Adapter.prototype.isPrototypeOf(CustomAdapter.prototype))\n    throw new TypeError('The adapter must inherit the Adapter class.')\n\n  return new CustomAdapter({\n    options: input[1] || {},\n    recordTypes: properties.recordTypes,\n    features: CustomAdapter.features,\n    common: common,\n    errors: errors,\n    keys: keys,\n    message: message,\n\n    // For backwards compatibility.\n    Promise: Promise\n  })\n}\n\n\nmodule.exports = AdapterSingleton\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/adapter/index.js":"'use strict'\n\nvar assign = require('../common/assign')\nvar memoryAdapter = require('./adapters/memory')\n\n\n/**\n * Adapter is an abstract base class containing methods to be implemented. All\n * records returned by the adapter must have the primary key `id`. The primary\n * key **MUST** be a string or a number.\n *\n * It has one static property, `defaultAdapter` which is a reference to the\n * memory adapter.\n */\nfunction Adapter (properties) {\n  assign(this, properties)\n}\n\n\n/**\n * The Adapter should not be instantiated directly, since the constructor\n * function accepts dependencies. The keys which are injected are:\n *\n * definitions.\n * - `recordTypes`: an object which enumerates record types and their\n * definitions.\n * - `options`: the options passed to the adapter.\n * - `common`: an object containing all internal utilities.\n * - `errors`: same as static property on Fortune class.\n * - `keys`: an object which enumerates reserved constants for record type\n * - `message`: a function with the signature (`id`, `language`, `data`).\n *\n * These keys are accessible on the instance (`this`).\n *\n * An adapter may expose a `features` static property, which is an object\n * that can contain boolean flags. These are used mainly for checking which\n * additional features may be tested.\n *\n * - `logicalOperators`: whether or not `and` and `or` queries are supported.\n */\nAdapter.prototype.constructor = function () {\n  // This exists here only for documentation purposes.\n}\n\ndelete Adapter.prototype.constructor\n\n\n/**\n * The responsibility of this method is to ensure that the record types\n * defined are consistent with the backing data store. If there is any\n * mismatch it should either try to reconcile differences or fail.\n * This method **SHOULD NOT** be called manually, and it should not accept\n * any parameters. This is the time to do setup tasks like create tables,\n * ensure indexes, etc. On successful completion, it should resolve to no\n * value.\n *\n * @return {Promise}\n */\nAdapter.prototype.connect = function () {\n  return Promise.resolve()\n}\n\n\n/**\n * Close the database connection.\n *\n * @return {Promise}\n */\nAdapter.prototype.disconnect = function () {\n  return Promise.resolve()\n}\n\n\n/**\n * Create records. A successful response resolves to the newly created\n * records.\n *\n * **IMPORTANT**: the record must have initial values for each field defined\n * in the record type. For non-array fields, it should be `null`, and for\n * array fields it should be `[]` (empty array). Note that not all fields in\n * the record type may be enumerable, such as denormalized inverse fields, so\n * it may be necessary to iterate over fields using\n * `Object.getOwnPropertyNames`.\n *\n * @param {String} type\n * @param {Object[]} records\n * @param {Object} [meta]\n * @return {Promise}\n */\nAdapter.prototype.create = function () {\n  return Promise.resolve([])\n}\n\n\n/**\n * Find records by IDs and options. If IDs is undefined, it should try to\n * return all records. However, if IDs is an empty array, it should be a\n * no-op. The format of the options may be as follows:\n *\n * ```js\n * {\n *   sort: { ... },\n *   fields: { ... },\n *   exists: { ... },\n *   match: { ... },\n *   range: { ... },\n *\n *   // Limit results to this number. Zero means no limit.\n *   limit: 0,\n *\n *   // Offset results by this much from the beginning.\n *   offset: 0,\n *\n *   // The logical operator \"and\", may be nested. Optional feature.\n *   and: { ... },\n *\n *   // The logical operator \"or\", may be nested. Optional feature.\n *   or: { ... },\n *\n *   // Reserved field for custom querying.\n *   query: null\n * }\n * ```\n *\n * For the fields `exists`, `match`, and `range`, the logical operator should\n * be \"and\". The `query` field may be used on a per adapter basis to provide\n * custom querying functionality.\n *\n * The syntax of the `sort` object is as follows:\n *\n * ```js\n * {\n *   age: false, // descending\n *   name: true // ascending\n * }\n * ```\n *\n * Fields can be specified to be either included or omitted, but not both.\n * Use the values `true` to include, or `false` to omit. The syntax of the\n * `fields` object is as follows:\n *\n * ```js\n * {\n *   name: true, // include this field\n *   age: true // also include this field\n * }\n * ```\n *\n * The `exists` object specifies if a field should exist or not (`true` or\n * `false`). For array fields, it should check for non-zero length.\n *\n * ```js\n * {\n *   name: true, // check if this fields exists\n *   age: false // check if this field doesn't exist\n * }\n * ```\n *\n * The syntax of the `match` object is straightforward:\n *\n * ```js\n * {\n *   name: 'value', // exact match or containment if array\n *   friends: [ 'joe', 'bob' ] // match any one of these values\n * }\n * ```\n *\n * The `range` object is used to filter between lower and upper bounds. It\n * should take precedence over `match`. For array fields, it should apply on\n * the length of the array. For singular link fields, it should not apply.\n *\n * ```js\n * {\n *   range: { // Ranges should be inclusive.\n *     age: [ 18, null ], // From 18 and above.\n *     name: [ 'a', 'd' ], // Starting with letters A through C.\n *     createdAt: [ null, new Date(2016, 0) ] // Dates until 2016.\n *   }\n * }\n * ```\n *\n * The return value of the promise should be an array, and the array **MUST**\n * have a `count` property that is the total number of records without limit\n * and offset.\n *\n * @param {String} type\n * @param {String[]|Number[]} [ids]\n * @param {Object} [options]\n * @param {Object} [meta]\n * @return {Promise}\n */\nAdapter.prototype.find = function () {\n  var results = []\n  results.count = 0\n  return Promise.resolve(results)\n}\n\n\n/**\n * Update records by IDs. Success should resolve to the number of records\n * updated. The `updates` parameter should be an array of objects that\n * correspond to updates by IDs. Each update object must be as follows:\n *\n * ```js\n * {\n *   // ID to update. Required.\n *   id: 1,\n *\n *   // Replace a value of a field. Use a `null` value to unset a field.\n *   replace: { name: 'Bob' },\n *\n *   // Append values to an array field. If the value is an array, all of\n *   // the values should be pushed.\n *   push: { pets: 1 },\n *\n *   // Remove values from an array field. If the value is an array, all of\n *   // the values should be removed.\n *   pull: { friends: [ 2, 3 ] },\n *\n *   // The `operate` field is specific to the adapter. This should take\n *   // precedence over all of the above. Warning: using this may bypass\n *   // field definitions and referential integrity. Use at your own risk.\n *   operate: null\n * }\n * ```\n *\n * Things to consider:\n *\n * - `push` and `pull` can not be applied to non-arrays.\n * - The same value in the same field should not exist in both `push` and\n * `pull`.\n *\n * @param {String} type\n * @param {Object[]} updates\n * @param {Object} [meta]\n * @return {Promise}\n */\nAdapter.prototype.update = function () {\n  return Promise.resolve(0)\n}\n\n\n/**\n * Delete records by IDs, or delete the entire collection if IDs are\n * undefined or empty. Success should resolve to the number of records\n * deleted.\n *\n * @param {String} type\n * @param {String[]|Number[]} [ids]\n * @param {Object} [meta]\n * @return {Promise}\n */\nAdapter.prototype.delete = function () {\n  return Promise.resolve(0)\n}\n\n\n/**\n * Begin a transaction to write to the data store. This method is optional\n * to implement, but useful for ACID. It should resolve to an object\n * containing all of the adapter methods.\n *\n * @return {Promise}\n */\nAdapter.prototype.beginTransaction = function () {\n  return Promise.resolve(this)\n}\n\n\n/**\n * End a transaction. This method is optional to implement.\n * It should return a Promise with no value if the transaction is\n * completed successfully, or reject the promise if it failed.\n *\n * @param {Error} [error] - If an error is passed, roll back the transaction.\n * @return {Promise}\n */\nAdapter.prototype.endTransaction = function () {\n  return Promise.resolve()\n}\n\n\n/**\n * Apply operators on a record, then return the record. If you make use of\n * update operators, you should implement this method so that the internal\n * implementation of update requests get records in the correct state. This\n * method is optional to implement.\n *\n * @param {Object} record\n * @param {Object} operators - The `operate` field on an `update` object.\n * @return {Object}\n */\nAdapter.prototype.applyOperators = function (record) {\n  return record\n}\n\n\n// Expose the default adapter.\nAdapter.DefaultAdapter = memoryAdapter(Adapter)\n\n// Expose features object.\nAdapter.features = {}\n\nmodule.exports = Adapter\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/index.js":"'use strict'\n\nmodule.exports = {\n  // Keys\n  constants: require('./constants'),\n  keys: require('./keys'),\n  events: require('./events'),\n  methods: require('./methods'),\n\n  // Utility functions\n  assign: require('./assign'),\n  castToNumber: require('./cast_to_number'),\n  castValue: require('./cast_value'),\n  clone: require('./clone'),\n  deepEqual: require('./deep_equal'),\n  generateId: require('./generate_id'),\n\n  // i18n\n  message: require('./message'),\n\n  // Typed responses\n  responses: require('./response_classes'),\n  errors: require('./errors'),\n  successes: require('./success'),\n\n  // Arrays\n  filter: require('./array/filter'),\n  find: require('./array/find'),\n  includes: require('./array/includes'),\n  map: require('./array/map'),\n  pull: require('./array/pull'),\n  reduce: require('./array/reduce'),\n  unique: require('./array/unique')\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/events.js":"'use strict'\n\nvar constants = require('./constants')\n\nexports.change = constants.change\nexports.sync = constants.sync\nexports.connect = constants.connect\nexports.disconnect = constants.disconnect\nexports.failure = constants.failure\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/methods.js":"'use strict'\n\nvar constants = require('./constants')\n\nexports.find = constants.find\nexports.create = constants.create\nexports.update = constants.update\nexports.delete = constants.delete\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/cast_to_number.js":"'use strict'\n\nmodule.exports = function castToNumber (id) {\n  // Stolen from jQuery source code:\n  // https://api.jquery.com/jQuery.isNumeric/\n  var float = Number.parseFloat(id)\n  return id - float + 1 >= 0 ? float : id\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/cast_value.js":"'use strict'\n\nvar errors = require('./errors')\nvar message = require('./message')\nvar castToNumber = require('./cast_to_number')\nvar BadRequestError = errors.BadRequestError\nvar buffer = Buffer.from || function (input, encoding) {\n  return new Buffer(input, encoding)\n}\n\n\nvar castByType = [\n  [ Number, function (x) { return parseFloat(x) } ],\n\n  [ Date, function (x, options) {\n    if (typeof x === 'string') {\n      x = Date.parse(x)\n      if (Number.isNaN(x)) throw new BadRequestError(\n        message('DateISO8601', options.language))\n    }\n\n    x = new Date(x)\n    if (Number.isNaN(x.getTime())) throw new BadRequestError(\n      message('DateInvalid', options.language))\n\n    return x\n  } ],\n\n  [ Buffer, function (x, options) {\n    var bufferEncoding = options && options.bufferEncoding ?\n      options.bufferEncoding : 'base64'\n\n    if (typeof x !== 'string') throw new BadRequestError(\n      message('BufferEncoding', options.language, {\n        bufferEncoding: bufferEncoding\n      }))\n\n    return buffer(x, bufferEncoding)\n  } ],\n\n  [ Boolean, function (x) {\n    if (typeof x === 'string') return x === 'true'\n    return Boolean(x)\n  } ],\n\n  [ Object, function (x, options) {\n    if (typeof x === 'string') return JSON.parse(x)\n    if (typeof x === 'object') return x\n    throw new BadRequestError(message('JSONParse', options.language))\n  } ],\n\n  [ String, function (x) { return '' + x } ]\n]\n\n\n/**\n * Cast a value to the given type. Skip if type is missing or value is null.\n *\n * @param {*} value\n * @param {Function} type - Constructor function.\n * @param {Object} [options]\n * @return {*}\n */\nmodule.exports = function castValue (value, type, options) {\n  var i, j, pair, cast\n\n  // Special case for empty string: it should be null.\n  if (value === '') return null\n\n  if (type)\n    for (i = 0, j = castByType.length; i < j; i++) {\n      pair = castByType[i]\n      if (pair[0] === type) {\n        cast = pair[1]\n        break\n      }\n    }\n  else return castToNumber(value)\n\n  return cast && value !== null ? cast(value, options) : value\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/clone.js":"'use strict'\n\n/**\n * A fast deep clone function, which covers mostly serializable objects.\n *\n * @param {*}\n * @return {*}\n */\nmodule.exports = function clone (input) {\n  var output, key, value, isArray\n\n  if (Array.isArray(input)) isArray = true\n  else if (input == null || Object.getPrototypeOf(input) !== Object.prototype)\n    return input\n\n  output = isArray ? [] : {}\n\n  for (key in input) {\n    value = input[key]\n    output[key] = value != null &&\n      Object.getPrototypeOf(value) === Object.prototype ||\n      Array.isArray(value) ? clone(value) : value\n  }\n\n  return output\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/success.js":"'use strict'\n\nvar responseClass = require('./response_classes')\n\nexports.OK = responseClass.OK\nexports.Created = responseClass.Created\nexports.Empty = responseClass.Empty\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/array/filter.js":"'use strict'\n\n/**\n * A more performant `Array.prototype.filter`.\n *\n * @param {*[]} array\n * @param {Function} fn\n * @return {Boolean}\n */\nmodule.exports = function filter (array, fn) {\n  var i, j, k = [], l = 0\n\n  for (i = 0, j = array.length; i < j; i++)\n    if (fn(array[i], i, array))\n      k[l++] = array[i]\n\n  return k\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/array/includes.js":"'use strict'\n\n/**\n * A more performant `Array.prototype.includes`.\n *\n * @param {*[]} array\n * @param {*} value\n * @return {Boolean}\n */\nmodule.exports = function includes (array, value) {\n  var i, j\n\n  for (i = 0, j = array.length; i < j; i++)\n    if (array[i] === value) return true\n\n  return false\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/array/reduce.js":"'use strict'\n\n/**\n * A more performant `Array.prototype.reduce`.\n *\n * @param {*[]} array\n * @param {Function} fn\n * @param {*} [initialValue]\n * @return {Boolean}\n */\nmodule.exports = function reduce (array, fn, initialValue) {\n  var i, j, k = initialValue\n\n  for (i = 0, j = array.length; i < j; i++)\n    k = fn(k, array[i], i, array)\n\n  return k\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/common/array/unique.js":"'use strict'\n\n/**\n * Return an array with unique values. Values must be primitive, and the array\n * may not be sparse.\n *\n * @param {Array}\n * @return {Array}\n */\nmodule.exports = function unique (a) {\n  var seen = {}\n  var result = []\n  var i, j, k\n\n  for (i = 0, j = a.length; i < j; i++) {\n    k = a[i]\n    if (seen.hasOwnProperty(k)) continue\n    result.push(k)\n    seen[k] = true\n  }\n\n  return result\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/record_type/validate.js":"'use strict'\n\nvar find = require('../common/array/find')\n\nvar keys = require('../common/keys')\nvar primaryKey = keys.primary\nvar typeKey = keys.type\nvar linkKey = keys.link\nvar inverseKey = keys.inverse\nvar isArrayKey = keys.isArray\n\nvar nativeTypes = [ String, Number, Boolean, Date, Object, Buffer ]\nvar plainObject = {}\n\n\n/**\n * Given a hash of field definitions, validate that the definitions are in the\n * correct format.\n *\n * @param {Object} fields\n * @return {Object}\n */\nmodule.exports = function validate (fields) {\n  var key\n\n  if (typeof fields !== 'object')\n    throw new TypeError('Type definition must be an object.')\n\n  for (key in fields) validateField(fields, key)\n\n  return fields\n}\n\n\n/**\n * Parse a field definition.\n *\n * @param {Object} fields\n * @param {String} key\n */\nfunction validateField (fields, key) {\n  var value = fields[key] = castShorthand(fields[key])\n\n  if (typeof value !== 'object' || value.constructor !== Object)\n    throw new TypeError('The definition of \"' + key + '\" must be an object.')\n\n  if (key === primaryKey)\n    throw new Error('Can not define primary key \"' + primaryKey + '\".')\n\n  if (key in plainObject)\n    throw new Error('Can not define field name \"' + key +\n      '\" which is in Object.prototype.')\n\n  if (!value[typeKey] && !value[linkKey])\n    throw new Error('The definition of \"' + key + '\" must contain either ' +\n      'the \"' + typeKey + '\" or \"' + linkKey + '\" property.')\n\n  if (value[typeKey] && value[linkKey])\n    throw new Error('Can not define both \"' + typeKey + '\" and \"' + linkKey +\n      '\" on \"' + key + '\".')\n\n  if (value[typeKey]) {\n    if (!find(nativeTypes, function (type) {\n      return type === value[typeKey]\n    }) && typeof value[typeKey] !== 'function')\n      throw new Error('The \"' + typeKey + '\" on \"' + key + '\" is invalid.')\n\n    if (typeof value[typeKey] === 'function' &&\n      !find(nativeTypes, function (type) {\n        return type === value[typeKey].prototype.constructor\n      }))\n      throw new Error('The \"' + typeKey + '\" on \"' + key + '\" must inherit ' +\n        'from a valid native type.')\n\n    if (value[inverseKey])\n      throw new Error('The field \"' + inverseKey + '\" may not be defined ' +\n        'on \"' + key + '\".')\n  }\n\n  if (value[linkKey]) {\n    if (typeof value[linkKey] !== 'string')\n      throw new TypeError('The \"' + linkKey + '\" on \"' + key +\n        '\" must be a string.')\n\n    if (value[inverseKey] && typeof value[inverseKey] !== 'string')\n      throw new TypeError('The \"' + inverseKey + '\" on \"' + key + '\" ' +\n        'must be a string.')\n  }\n\n  if (value[isArrayKey] && typeof value[isArrayKey] !== 'boolean')\n    throw new TypeError('The key \"' + isArrayKey + '\" on \"' + key + '\" ' +\n        'must be a boolean.')\n}\n\n\n/**\n * Cast shorthand definition to standard definition.\n *\n * @param {*} value\n * @return {Object}\n */\nfunction castShorthand (value) {\n  var obj\n\n  if (typeof value === 'string') obj = { link: value }\n  else if (typeof value === 'function') obj = { type: value }\n  else if (Array.isArray(value)) {\n    obj = {}\n\n    if (value[1]) obj.inverse = value[1]\n    else obj.isArray = true\n\n    // Extract type or link.\n    if (Array.isArray(value[0])) {\n      obj.isArray = true\n      value = value[0][0]\n    }\n    else value = value[0]\n\n    if (typeof value === 'string') obj.link = value\n    else if (typeof value === 'function') obj.type = value\n  }\n  else return value\n\n  return obj\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/record_type/ensure_types.js":"'use strict'\n\nvar keys = require('../common/keys')\nvar linkKey = keys.link\nvar inverseKey = keys.inverse\nvar isArrayKey = keys.isArray\nvar denormalizedInverseKey = keys.denormalizedInverse\n\n\n// Generate denormalized inverse field name.\nvar denormalizedPrefix = '__'\nvar denormalizedDelimiter = '_'\nvar denormalizedPostfix = '_inverse'\n\n\n/**\n * Analyze the `types` object to see if `link` and `inverse` values are\n * valid. Also assign denormalized inverse fields.\n *\n * @param {Object} types\n */\nmodule.exports = function ensureTypes (types) {\n  var type, field, definition, linkedFields,\n    denormalizedField, denormalizedDefinition\n\n  for (type in types)\n    for (field in types[type]) {\n      definition = types[type][field]\n\n      if (!(linkKey in definition)) continue\n\n      if (!types.hasOwnProperty(definition[linkKey]))\n        throw new Error('The value for \"' + linkKey + '\" on \"' + field +\n          '\" in type \"' + type +\n          '\" is invalid, the record type does not exist.')\n\n      linkedFields = types[definition[linkKey]]\n\n      if (inverseKey in definition) {\n        if (!linkedFields.hasOwnProperty(definition[inverseKey]))\n          throw new Error('The value for \"' + inverseKey + '\" on \"' + field +\n            '\" in type \"' + type + '\" is invalid, the field does not exist.')\n\n        if (linkedFields[definition[inverseKey]][inverseKey] !== field)\n          throw new Error('The value for \"' + inverseKey + '\" on \"' + field +\n            '\" in type \"' + type +\n            '\" is invalid, the inversely related field must define its ' +\n            'inverse as \"' + field + '\".')\n\n        if (linkedFields[definition[inverseKey]][linkKey] !== type)\n          throw new Error('The value for \"' + linkKey + '\" on \"' + field +\n            '\" in type \"' + type +\n            '\" is invalid, the inversely related field must define its link ' +\n            'as \"' + type + '\".')\n\n        continue\n      }\n\n      // Need to assign denormalized inverse. The denormalized inverse field\n      // is basically an automatically assigned inverse field that should\n      // not be visible to the client, but exists in the data store.\n      denormalizedField = denormalizedPrefix + type +\n        denormalizedDelimiter + field + denormalizedPostfix\n\n      Object.defineProperty(definition, inverseKey, {\n        value: denormalizedField\n      })\n\n      denormalizedDefinition = {}\n      denormalizedDefinition[linkKey] = type\n      denormalizedDefinition[inverseKey] = field\n      denormalizedDefinition[isArrayKey] = true\n      denormalizedDefinition[denormalizedInverseKey] = true\n\n      Object.defineProperty(linkedFields, denormalizedField, {\n        value: denormalizedDefinition\n      })\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/dispatch/index.js":"'use strict'\n\nvar assign = require('../common/assign')\nvar unique = require('../common/array/unique')\nvar message = require('../common/message')\n\nvar responseClass = require('../common/response_classes')\nvar BadRequestError = responseClass.BadRequestError\nvar NotFoundError = responseClass.NotFoundError\nvar MethodError = responseClass.MethodError\nvar OK = responseClass.OK\nvar Empty = responseClass.Empty\nvar Created = responseClass.Created\n\nvar methods = require('../common/methods')\nvar findMethod = methods.find\nvar createMethod = methods.create\n\n\n/*!\n * Internal function to dispatch a request.\n *\n * @param {Object} scope\n * @param {Object} options\n * @return {Promise}\n */\nfunction dispatch (scope, options) {\n  var flows = scope.flows\n  var recordTypes = scope.recordTypes\n  var context = setDefaults(options)\n\n  // Start a promise chain.\n  return Promise.resolve(context)\n\n  .then(function (context) {\n    var method = context.request.method\n    var type = context.request.type\n    var ids = context.request.ids\n    var language = context.request.meta.language\n    var chain, flow, error, i, j\n\n    // Set the language.\n    language = context.request.meta.language\n\n    // Make sure that IDs are an array of unique values.\n    if (ids) context.request.ids = unique(ids)\n\n    // If a type is unspecified, block the request.\n    if (type === null) {\n      error = new BadRequestError(message('UnspecifiedType', language))\n      error.isTypeUnspecified = true\n      throw error\n    }\n\n    // If a type is specified and it doesn't exist, block the request.\n    if (!recordTypes.hasOwnProperty(type))\n      throw new NotFoundError(\n        message('InvalidType', language, { type: type }))\n\n    // Block invalid method.\n    if (!(method in flows))\n      throw new MethodError(\n        message('InvalidMethod', language, { method: method }))\n\n    chain = Promise.resolve(context)\n    flow = flows[method]\n\n    for (i = 0, j = flow.length; i < j; i++)\n      chain = chain.then(flow[i])\n\n    return chain\n  })\n\n  .then(function (context) {\n    var method = context.request.method\n    var response = context.response\n    var payload = response.payload\n\n    if (!payload) return new Empty(response)\n    if (method === createMethod) return new Created(response)\n\n    return new OK(response)\n  })\n\n  .catch(function (error) {\n    throw assign(error, context.response)\n  })\n}\n\n\n// Re-exporting internal middlewares.\ndispatch.middlewares = {\n  create: require('./create'),\n  'delete': require('./delete'),\n  update: require('./update'),\n  find: require('./find'),\n  include: require('./include'),\n  end: require('./end')\n}\n\n\n/*!\n * Set default options on a context's request. For internal use.\n *\n * @param {Object} [options]\n * @return {Object}\n */\nfunction setDefaults (options) {\n  var context = {\n    request: {\n      method: findMethod,\n      type: null,\n      ids: null,\n      options: {},\n      include: [],\n      meta: {},\n      payload: null\n    },\n    response: {\n      meta: {},\n      payload: null\n    }\n  }\n\n  assign(context.request, options)\n\n  return context\n}\n\n\nmodule.exports = dispatch\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/dispatch/create.js":"'use strict'\n\nvar validateRecords = require('./validate_records')\nvar checkLinks = require('./check_links')\nvar enforce = require('../record_type/enforce')\nvar message = require('../common/message')\nvar map = require('../common/array/map')\n\nvar errors = require('../common/errors')\nvar BadRequestError = errors.BadRequestError\n\nvar updateHelpers = require('./update_helpers')\nvar getUpdate = updateHelpers.getUpdate\nvar addId = updateHelpers.addId\n\nvar constants = require('../common/constants')\nvar changeEvent = constants.change\nvar createMethod = constants.create\nvar updateMethod = constants.update\nvar primaryKey = constants.primary\nvar linkKey = constants.link\nvar inverseKey = constants.inverse\nvar isArrayKey = constants.isArray\nvar denormalizedInverseKey = constants.denormalizedInverse\n\n\n/**\n * Extend context so that it includes the parsed records and create them.\n * This mutates the response object.\n *\n * @return {Promise}\n */\nmodule.exports = function (context) {\n  var self = this\n  var adapter = self.adapter\n  var recordTypes = self.recordTypes\n  var hooks = self.hooks\n  var updates = {}\n  var links = []\n  var transaction, records, type, meta, hook, fields, language\n\n  // Start a promise chain.\n  return Promise.resolve(context.request.payload)\n\n  .then(function (payload) {\n    var i, j, field\n\n    records = payload\n\n    if (!records || !records.length)\n      throw new BadRequestError(message('CreateRecordsInvalid', language))\n\n    type = context.request.type\n    meta = context.request.meta\n    language = meta.language\n\n    hook = hooks[type]\n    fields = recordTypes[type]\n\n    for (field in fields) {\n      if (linkKey in fields[field])\n        links.push(field)\n\n      // Delete denormalized inverse fields.\n      if (denormalizedInverseKey in fields[field])\n        for (i = 0, j = records.length; i < j; i++)\n          delete records[i][field]\n    }\n\n    return adapter.beginTransaction()\n  })\n\n  .then(function (result) {\n    context.transaction = transaction = result\n\n    return typeof hook[0] === 'function' ?\n      Promise.all(map(records, function (record) {\n        return hook[0](context, record)\n      })) : records\n  })\n\n  .then(function (results) {\n    return Promise.all(map(results, function (record, i) {\n      if (record) records[i] = record\n      else record = records[i]\n\n      // Enforce the fields.\n      enforce(type, record, fields, meta)\n\n      // Ensure referential integrity.\n      return checkLinks.call(self, record, fields, links, meta)\n    }))\n  })\n\n  .then(function () {\n    validateRecords.call(self, records, fields, links, meta)\n    return transaction.create(type, records, meta)\n  })\n\n  .then(function (createdRecords) {\n    var i, j, k, l, m, n, record, field, inverseField,\n      linkedType, linkedIsArray, linkedIds, id\n\n    // Update inversely linked records on created records.\n    // Trying to batch updates to be as few as possible.\n    var idCache = {}\n\n    // Adapter must return something.\n    if (!createdRecords.length)\n      throw new BadRequestError(message('CreateRecordsFail', language))\n\n    records = createdRecords\n\n    Object.defineProperty(context.response, 'records', {\n      configurable: true,\n      value: records\n    })\n\n    // Iterate over each record to generate updates object.\n    for (i = 0, j = records.length; i < j; i++) {\n      record = records[i]\n\n      // Each created record must have an ID.\n      if (!(primaryKey in record))\n        throw new Error(message('CreateRecordMissingID', language))\n\n      for (k = 0, l = links.length; k < l; k++) {\n        field = links[k]\n        inverseField = fields[field][inverseKey]\n\n        if (!record.hasOwnProperty(field) || !inverseField) continue\n\n        linkedType = fields[field][linkKey]\n        linkedIsArray =\n          recordTypes[linkedType][inverseField][isArrayKey]\n        linkedIds = Array.isArray(record[field]) ?\n          record[field] : [ record[field] ]\n\n        // Do some initialization.\n        if (!updates[linkedType]) updates[linkedType] = []\n        if (!idCache[linkedType]) idCache[linkedType] = {}\n\n        for (m = 0, n = linkedIds.length; m < n; m++) {\n          id = linkedIds[m]\n          if (id !== null)\n            addId(record[primaryKey],\n              getUpdate(linkedType, id, updates, idCache),\n              inverseField, linkedIsArray)\n        }\n      }\n    }\n\n    return Promise.all(map(Object.keys(updates), function (type) {\n      return updates[type].length ?\n        transaction.update(type, updates[type], meta) :\n        null\n    }))\n  })\n\n  .then(function () {\n    return transaction.endTransaction()\n  })\n\n  // This makes sure to call `endTransaction` before re-throwing the error.\n  .catch(function (error) {\n    if (transaction) transaction.endTransaction(error)\n    throw error\n  })\n\n  .then(function () {\n    var eventData = {}, currentType\n\n    eventData[createMethod] = {}\n    eventData[createMethod][type] = records\n\n    for (currentType in updates) {\n      if (!updates[currentType].length) continue\n      if (!(updateMethod in eventData)) eventData[updateMethod] = {}\n      eventData[updateMethod][currentType] = updates[currentType]\n    }\n\n    // Summarize changes during the lifecycle of the request.\n    self.emit(changeEvent, eventData)\n\n    return context\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/dispatch/validate_records.js":"'use strict'\n\nvar message = require('../common/message')\n\nvar errors = require('../common/errors')\nvar ConflictError = errors.ConflictError\n\nvar keys = require('../common/keys')\nvar linkKey = keys.link\nvar isArrayKey = keys.isArray\nvar inverseKey = keys.inverse\n\n/**\n * Do some validation on records to be created or updated to determine\n * if there are any records which have overlapping to-one relationships,\n * or non-unique array relationships.\n *\n * @param {Object[]} records\n * @param {Object} fields\n * @param {Object} links\n * @param {Object} meta\n */\nmodule.exports = function validateRecords (records, fields, links, meta) {\n  var recordTypes = this.recordTypes\n  var language = meta.language\n  var toOneMap = {}\n  var i, j, k, l, m, n, value, field, record, id, ids, seen,\n    fieldLink, fieldInverse, fieldIsArray, inverseIsArray\n\n  for (i = 0, j = links.length; i < j; i++) {\n    field = links[i]\n    fieldLink = fields[field][linkKey]\n    fieldInverse = fields[field][inverseKey]\n    fieldIsArray = fields[field][isArrayKey]\n    inverseIsArray = recordTypes[fieldLink][fieldInverse][isArrayKey]\n\n    if (fieldIsArray)\n      for (k = 0, l = records.length; k < l; k++) {\n        record = records[k]\n        if (!Array.isArray(record[field])) continue\n        ids = record[field]\n        seen = {}\n\n        for (m = 0, n = ids.length; m < n; m++) {\n          id = ids[m]\n          if (seen.hasOwnProperty(id)) throw new ConflictError(\n            message('CollisionDuplicate', language, { id: id, field: field }))\n          else seen[id] = true\n        }\n      }\n\n    if (!inverseIsArray) {\n      toOneMap[field] = {}\n\n      for (k = 0, l = records.length; k < l; k++) {\n        record = records[k]\n        value = record[field]\n        ids = Array.isArray(value) ? value : value ? [ value ] : []\n\n        for (m = 0, n = ids.length; m < n; m++) {\n          id = ids[m]\n          if (!toOneMap[field].hasOwnProperty(id)) toOneMap[field][id] = true\n          else throw new ConflictError(\n            message('CollisionToOne', language, { field: field }))\n        }\n      }\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/dispatch/check_links.js":"'use strict'\n\nvar message = require('../common/message')\nvar unique = require('../common/array/unique')\nvar map = require('../common/array/map')\nvar includes = require('../common/array/includes')\n\nvar errors = require('../common/errors')\nvar BadRequestError = errors.BadRequestError\n\nvar keys = require('../common/keys')\nvar primaryKey = keys.primary\nvar linkKey = keys.link\nvar isArrayKey = keys.isArray\nvar inverseKey = keys.inverse\n\n\n/**\n * Ensure referential integrity by checking if related records exist.\n *\n * @param {Object} record\n * @param {Object} fields\n * @param {String[]} links - An array of strings indicating which fields are\n * links. Need to pass this so that it doesn't get computed each time.\n * @param {Object} [meta]\n * @return {Promise}\n */\nmodule.exports = function checkLinks (record, fields, links, meta) {\n  var adapter = this.adapter\n  var enforceLinks = this.options.settings.enforceLinks\n\n  return Promise.all(map(links, function (field) {\n    var ids = Array.isArray(record[field]) ? record[field] :\n      !record.hasOwnProperty(field) || record[field] === null ?\n      [] : [ record[field] ]\n    var fieldLink = fields[field][linkKey]\n    var fieldInverse = fields[field][inverseKey]\n    var findOptions = { fields: {} }\n\n    // Don't need the entire records.\n    findOptions.fields[fieldInverse] = true\n\n    return new Promise(function (resolve, reject) {\n      if (!ids.length) return resolve()\n\n      return adapter.find(fieldLink, ids, findOptions, meta)\n\n      .then(function (records) {\n        var recordIds, i, j\n\n        if (enforceLinks) {\n          recordIds = unique(map(records, function (record) {\n            return record[primaryKey]\n          }))\n\n          for (i = 0, j = ids.length; i < j; i++)\n            if (!includes(recordIds, ids[i]))\n              return reject(new BadRequestError(\n                message('RelatedRecordNotFound', meta.language,\n                  { field: field })\n              ))\n        }\n\n        return resolve(records)\n      })\n    })\n  }))\n\n  .then(function (partialRecords) {\n    var object = {}, records, i, j\n\n    for (i = 0, j = partialRecords.length; i < j; i++) {\n      records = partialRecords[i]\n\n      if (records) object[links[i]] =\n        fields[links[i]][isArrayKey] ? records : records[0]\n    }\n\n    return object\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/record_type/enforce.js":"'use strict'\n\nvar message = require('../common/message')\nvar find = require('../common/array/find')\n\nvar errors = require('../common/errors')\nvar BadRequestError = errors.BadRequestError\n\nvar keys = require('../common/keys')\nvar primaryKey = keys.primary\nvar typeKey = keys.type\nvar linkKey = keys.link\nvar isArrayKey = keys.isArray\n\n\n// Check input values.\nvar checkInput = [\n  [ String, function (value) {\n    return typeof value === 'string'\n  } ],\n  [ Number, function (value) {\n    return typeof value === 'number'\n  } ],\n  [ Boolean, function (value) {\n    return typeof value === 'boolean'\n  } ],\n  [ Date, function (value) {\n    return value && typeof value.getTime === 'function' &&\n      !Number.isNaN(value.getTime())\n  } ],\n  [ Object, function (value) {\n    return value !== null && typeof value === 'object'\n  } ],\n  [ Buffer, function (value) {\n    return Buffer.isBuffer(value)\n  } ]\n]\n\n\n/**\n * Throw errors for mismatched types on a record.\n *\n * @param {String} type\n * @param {Object} record\n * @param {Object} fields\n * @param {Object} meta\n * @return {Object}\n */\nmodule.exports = function enforce (type, record, fields, meta) {\n  var i, j, key, value, fieldDefinition, language\n\n  if (!meta) meta = {}\n  language = meta.language\n\n  for (key in record) {\n    fieldDefinition = fields[key]\n\n    if (!fieldDefinition) {\n      if (key !== primaryKey) delete record[key]\n      continue\n    }\n\n    value = record[key]\n\n    if (fieldDefinition[typeKey]) {\n      if (fieldDefinition[isArrayKey]) {\n        // If the field is defined as an array but the value is not,\n        // then throw an error.\n        if (!Array.isArray(value))\n          throw new BadRequestError(message('EnforceArrayType', language, {\n            key: key, type: fieldDefinition[typeKey].name\n          }))\n\n        for (i = 0, j = value.length; i < j; i++)\n          checkValue(fieldDefinition, key, value[i], meta)\n      }\n      else checkValue(fieldDefinition, key, value, meta)\n\n      continue\n    }\n\n    if (fieldDefinition[linkKey]) {\n      if (fieldDefinition[isArrayKey]) {\n        if (!Array.isArray(value))\n          throw new BadRequestError(\n            message('EnforceArray', language, { key: key }))\n\n        if (type === fieldDefinition[linkKey] &&\n          find(value, matchId(record[primaryKey])))\n          throw new BadRequestError(\n            message('EnforceSameID', language, { key: key }))\n\n        continue\n      }\n\n      if (Array.isArray(value))\n        throw new BadRequestError(\n          message('EnforceSingular', language, { key: key }))\n\n      if (type === fieldDefinition[linkKey] && record[primaryKey] === value)\n        throw new BadRequestError(\n          message('EnforceSameID', language, { key: key }))\n\n      continue\n    }\n  }\n\n  return record\n}\n\n\nfunction checkValue (field, key, value, meta) {\n  var language = meta.language\n  var check\n\n  // Skip `null` case.\n  if (value === null) return\n\n  check = find(checkInput, function (pair) {\n    return pair[0] === field[typeKey]\n  })\n  if (check) check = check[1]\n  else check = field[typeKey]\n\n  // Fields may be nullable, but if they're defined, then they must be defined\n  // properly.\n  if (!check(value)) throw new BadRequestError(\n    message(field[isArrayKey] ? 'EnforceValueArray' : 'EnforceValue',\n    language, { key: key, type: field[typeKey].name }))\n}\n\n\nfunction matchId (a) {\n  return function (b) {\n    return a === b\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/dispatch/update_helpers.js":"'use strict'\n\nvar find = require('../common/array/find')\n\nvar keys = require('../common/keys')\nvar primaryKey = keys.primary\n\n\n// Get a related update object by ID, or return a new one if not found.\nexports.getUpdate = function (type, id, updates, cache) {\n  var update\n\n  if (cache[type] && cache[type][id])\n    return find(updates[type],\n      function (update) {\n        return update[primaryKey] === id\n      })\n\n  update = { id: id }\n  if (!updates[type]) updates[type] = []\n  updates[type].push(update)\n  cache[type] = {}\n  cache[type][id] = true\n  return update\n}\n\n\n// Add an ID to an update object.\nexports.addId = function (id, update, field, isArray) {\n  if (isArray) {\n    if (!update.push) update.push = {}\n    if (!update.push[field]) update.push[field] = []\n    update.push[field].push(id)\n    return\n  }\n\n  if (!update.replace) update.replace = {}\n  update.replace[field] = id\n}\n\n\n// Remove an ID from an update object.\nexports.removeId = function (id, update, field, isArray) {\n  if (isArray) {\n    if (!update.pull) update.pull = {}\n    if (!update.pull[field]) update.pull[field] = []\n    update.pull[field].push(id)\n    return\n  }\n\n  if (!update.replace) update.replace = {}\n  update.replace[field] = null\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/dispatch/delete.js":"'use strict'\n\nvar message = require('../common/message')\nvar map = require('../common/array/map')\n\nvar errors = require('../common/errors')\nvar NotFoundError = errors.NotFoundError\n\nvar updateHelpers = require('./update_helpers')\nvar getUpdate = updateHelpers.getUpdate\nvar removeId = updateHelpers.removeId\n\nvar constants = require('../common/constants')\nvar changeEvent = constants.change\nvar deleteMethod = constants.delete\nvar updateMethod = constants.update\nvar primaryKey = constants.primary\nvar linkKey = constants.link\nvar inverseKey = constants.inverse\nvar isArrayKey = constants.isArray\n\n\n/**\n * Delete records. This does not mutate context.\n *\n * @return {Promise}\n */\nmodule.exports = function (context) {\n  var self = this\n  var request = context.request\n  var type = request.type\n  var ids = request.ids\n  var meta = request.meta\n  var language = meta.language\n  var adapter = self.adapter\n  var recordTypes = self.recordTypes\n  var hooks = self.hooks\n  var updates = {}\n  var fields = recordTypes[type]\n  var hook = hooks[type]\n  var links = []\n  var transaction, field, records\n\n  for (field in fields)\n    if (linkKey in fields[field]) links.push(field)\n\n  if (!ids || !ids.length)\n    throw new NotFoundError(message('DeleteRecordsMissingID', language))\n\n  return adapter.find(type, ids, null, meta)\n\n  .then(function (foundRecords) {\n    records = foundRecords\n\n    if (records.length < ids.length)\n      throw new NotFoundError(message('DeleteRecordsInvalid', language))\n\n    Object.defineProperty(context.response, 'records', {\n      configurable: true,\n      value: records\n    })\n\n    return adapter.beginTransaction()\n  })\n\n  .then(function (result) {\n    context.transaction = transaction = result\n\n    return typeof hook[0] === 'function' ?\n      Promise.all(map(records, function (record) {\n        return hook[0](context, record)\n      })) : records\n  })\n\n  .then(function () {\n    return transaction.delete(type, ids, meta)\n  })\n\n  .then(function (count) {\n    var i, j, k, l, m, n, record, field, id, inverseField,\n      linkedType, linkedIsArray, linkedIds\n\n    // Remove all instances of the deleted IDs in all records.\n    var idCache = {}\n\n    // Sanity check.\n    if (count < ids.length)\n      throw new Error(message('DeleteRecordsFail', language))\n\n    // Loop over each record to generate updates object.\n    for (i = 0, j = records.length; i < j; i++) {\n      record = records[i]\n      for (k = 0, l = links.length; k < l; k++) {\n        field = links[k]\n        inverseField = fields[field][inverseKey]\n\n        if (!record.hasOwnProperty(field) || !inverseField) continue\n\n        linkedType = fields[field][linkKey]\n        linkedIsArray = recordTypes[linkedType][inverseField][isArrayKey]\n        linkedIds = Array.isArray(record[field]) ?\n          record[field] : [ record[field] ]\n\n        // Do some initialization.\n        if (!updates[linkedType]) updates[linkedType] = []\n        if (!idCache[linkedType]) idCache[linkedType] = {}\n\n        for (m = 0, n = linkedIds.length; m < n; m++) {\n          id = linkedIds[m]\n          if (id !== null)\n            removeId(record[primaryKey],\n              getUpdate(linkedType, id, updates, idCache),\n              inverseField, linkedIsArray)\n        }\n      }\n    }\n\n    return Promise.all(map(Object.keys(updates), function (type) {\n      return updates[type].length ?\n        transaction.update(type, updates[type], meta) :\n        null\n    }))\n  })\n\n  .then(function () {\n    return transaction.endTransaction()\n  })\n\n  // This makes sure to call `endTransaction` before re-throwing the error.\n  .catch(function (error) {\n    if (transaction) transaction.endTransaction(error)\n    throw error\n  })\n\n  .then(function () {\n    var eventData = {}, currentType\n\n    eventData[deleteMethod] = {}\n    eventData[deleteMethod][type] = ids\n\n    for (currentType in updates) {\n      if (!updates[currentType].length) continue\n      if (!(updateMethod in eventData)) eventData[updateMethod] = {}\n      eventData[updateMethod][currentType] = updates[currentType]\n    }\n\n    // Summarize changes during the lifecycle of the request.\n    self.emit(changeEvent, eventData)\n\n    return context\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/dispatch/update.js":"'use strict'\n\nvar deepEqual = require('../common/deep_equal')\nvar assign = require('../common/assign')\nvar clone = require('../common/clone')\nvar validateRecords = require('./validate_records')\nvar checkLinks = require('./check_links')\nvar enforce = require('../record_type/enforce')\nvar message = require('../common/message')\nvar applyUpdate = require('../common/apply_update')\n\nvar updateHelpers = require('./update_helpers')\nvar getUpdate = updateHelpers.getUpdate\nvar addId = updateHelpers.addId\nvar removeId = updateHelpers.removeId\n\nvar errors = require('../common/errors')\nvar NotFoundError = errors.NotFoundError\nvar BadRequestError = errors.BadRequestError\n\nvar find = require('../common/array/find')\nvar includes = require('../common/array/includes')\nvar map = require('../common/array/map')\n\nvar constants = require('../common/constants')\nvar changeEvent = constants.change\nvar updateMethod = constants.update\nvar primaryKey = constants.primary\nvar linkKey = constants.link\nvar inverseKey = constants.inverse\nvar isArrayKey = constants.isArray\nvar denormalizedInverseKey = constants.denormalizedInverse\n\n\n/**\n * Do updates. First, it must find the records to update, then run hooks\n * and validation, then apply the update as well as links on related records.\n *\n * @return {Promise}\n */\nmodule.exports = function (context) {\n  var self = this\n  var adapter = self.adapter\n  var recordTypes = self.recordTypes\n  var hooks = self.hooks\n\n  // Keyed by update, valued by record.\n  var updateMap = new WeakMap()\n\n  // Keyed by update, valued by hash of linked records.\n  var linkedMap = new WeakMap()\n\n  var relatedUpdates = {}\n  var hookedUpdates = []\n\n  var links = []\n  var transaction, updates, fields, hook, type, meta, language\n\n  // Start a promise chain.\n  return Promise.resolve(context.request.payload)\n\n  .then(function (payload) {\n    var i, j, update, field\n\n    updates = payload\n    validateUpdates(updates, context.request.meta)\n\n    type = context.request.type\n    meta = context.request.meta\n    language = meta.language\n\n    fields = recordTypes[type]\n    hook = hooks[type]\n\n    // Delete denormalized inverse fields, can't be updated.\n    for (field in fields) {\n      if (linkKey in fields[field]) links.push(field)\n      if (denormalizedInverseKey in fields[field])\n        for (i = 0, j = updates.length; i < j; i++) {\n          update = updates[i]\n          if (update.replace) delete update.replace[field]\n          if (update.pull) delete update.pull[field]\n          if (update.push) delete update.push[field]\n        }\n    }\n\n    return adapter.beginTransaction()\n  })\n\n  .then(function (result) {\n    context.transaction = transaction = result\n\n    return adapter.find(type, map(updates, function (update) {\n      return update[primaryKey]\n    }), null, meta)\n  })\n\n  .then(function (records) {\n    if (records.length < updates.length)\n      throw new NotFoundError(message('UpdateRecordMissing', language))\n\n    return Promise.all(map(records, function (record) {\n      var update, cloneUpdate\n      var hasHook = typeof hook[0] === 'function'\n      var id = record[primaryKey]\n\n      update = find(updates, function (update) {\n        return update[primaryKey] === id\n      })\n\n      if (!update) throw new NotFoundError(\n        message('UpdateRecordMissing', language))\n\n      if (hasHook) cloneUpdate = clone(update)\n\n      return Promise.resolve(hasHook ?\n        hook[0](context, record, update) : update)\n      .then(function (result) {\n        if (result) update = result\n\n        if (hasHook) {\n          // Check if the update has been modified or not.\n          if (!deepEqual(update, cloneUpdate))\n            context.response.meta.updateModified = true\n\n          // Runtime safety check: primary key must be the same.\n          if (update[primaryKey] !== id) throw new BadRequestError(\n            message('InvalidID', language))\n        }\n\n        hookedUpdates.push(update)\n        updateMap.set(update, record)\n\n        // Shallow clone the record.\n        record = assign({}, record)\n\n        // Apply updates to record.\n        applyUpdate(record, update)\n\n        // Apply operators to record.\n        if (update.operate)\n          record = adapter.applyOperators(record, update.operate)\n\n        // Enforce the fields.\n        enforce(type, record, fields, meta)\n\n        // Ensure referential integrity.\n        return checkLinks.call(self, record, fields, links, meta)\n        .then(function (linked) {\n          linkedMap.set(update, linked)\n          return record\n        })\n      })\n    }))\n  })\n\n  .then(function (records) {\n    var i, j\n\n    validateRecords.call(self, records, fields, links, meta)\n\n    Object.defineProperty(context.response, 'records', {\n      configurable: true,\n      value: records\n    })\n\n    // Drop fields in the updates that aren't defined in the record type\n    // before doing the update.\n    for (i = 0, j = hookedUpdates.length; i < j; i++)\n      dropFields(hookedUpdates[i], fields)\n\n    return transaction.update(type, hookedUpdates, meta)\n  })\n\n  .then(function () {\n    var inverseField, isArray, linkedType, linkedIsArray, linked, record,\n      partialRecord, partialRecords, ids, id, push, pull, update, field\n    var i, j, k, l, m, n\n\n    // Build up related updates based on update objects.\n    var idCache = {}\n\n    // Iterate over each update to generate related updates.\n    for (i = 0, j = hookedUpdates.length; i < j; i++) {\n      update = hookedUpdates[i]\n\n      for (k = 0, l = links.length; k < l; k++) {\n        field = links[k]\n        inverseField = fields[field][inverseKey]\n\n        if (!inverseField) continue\n\n        isArray = fields[field][isArrayKey]\n        linkedType = fields[field][linkKey]\n        linkedIsArray =\n          recordTypes[linkedType][inverseField][isArrayKey]\n\n        // Do some initialization.\n        if (!relatedUpdates[linkedType]) relatedUpdates[linkedType] = []\n        if (!idCache[linkedType]) idCache[linkedType] = {}\n\n        record = updateMap.get(update)\n        linked = linkedMap.get(update)\n\n        // Replacing a link field is pretty complicated.\n        if (update.replace && update.replace.hasOwnProperty(field)) {\n          id = update.replace[field]\n\n          if (!Array.isArray(id)) {\n            // Don't need to worry about inverse updates if the value does not\n            // change.\n            if (id === record[field]) continue\n\n            // Set related field.\n            if (id !== null)\n              addId(update[primaryKey],\n                getUpdate(linkedType, id, relatedUpdates, idCache),\n                inverseField, linkedIsArray)\n\n            // Unset 2nd degree related record.\n            if (linked.hasOwnProperty(field) &&\n              linked[field][inverseField] !== null &&\n              !linkedIsArray &&\n              linked[field][inverseField] !== update[primaryKey])\n              removeId(id,\n                getUpdate(\n                  linkedType, linked[field][inverseField],\n                  relatedUpdates, idCache),\n                inverseField, linkedIsArray)\n\n            // For unsetting, remove ID from related record.\n            if (record[field] !== null &&\n              record[field] !== update[field] &&\n              record[field] !== id)\n              removeId(update[primaryKey],\n                getUpdate(\n                  linkedType, record[field], relatedUpdates, idCache),\n                inverseField, linkedIsArray)\n\n            // After this point, there's no need to go over push/pull.\n            continue\n          }\n\n          ids = id\n\n          // Compute differences for pull, and mutate the update.\n          for (m = 0, n = record[field].length; m < n; m++) {\n            id = record[field][m]\n            if (!includes(ids, id)) {\n              if (!('pull' in update)) update.pull = {}\n              if (update.pull.hasOwnProperty(field)) {\n                if (Array.isArray(update.pull[field])) {\n                  update.pull[field].push(id)\n                  continue\n                }\n                update.pull[field] = [ update.pull[field], id ]\n                continue\n              }\n              update.pull[field] = [ id ]\n            }\n          }\n\n          // Compute differences for push, and mutate the update.\n          for (m = 0, n = ids.length; m < n; m++) {\n            id = ids[m]\n            if (!includes(record[field], id)) {\n              if (!('push' in update)) update.push = {}\n              if (update.push.hasOwnProperty(field)) {\n                if (Array.isArray(update.push[field])) {\n                  update.push[field].push(id)\n                  continue\n                }\n                update.push[field] = [ update.push[field], id ]\n                continue\n              }\n              update.push[field] = [ id ]\n            }\n          }\n\n          // Delete the original replace, since it is no longer valid.\n          delete update.replace[field]\n        }\n\n        if (update.pull && update.pull[field]) {\n          pull = Array.isArray(update.pull[field]) ?\n            update.pull[field] : [ update.pull[field] ]\n\n          for (m = 0, n = pull.length; m < n; m++) {\n            id = pull[m]\n            if (id !== null)\n              removeId(update[primaryKey],\n                getUpdate(linkedType, id, relatedUpdates, idCache),\n                inverseField, linkedIsArray)\n          }\n        }\n\n        if (update.push && update.push[field]) {\n          push = Array.isArray(update.push[field]) ?\n            update.push[field] : [ update.push[field] ]\n\n          for (m = 0, n = push.length; m < n; m++) {\n            id = push[m]\n            if (id !== null)\n              addId(update[primaryKey],\n                getUpdate(linkedType, id, relatedUpdates, idCache),\n                inverseField, linkedIsArray)\n          }\n        }\n\n        // Unset from 2nd degree related records.\n        if (linked.hasOwnProperty(field) && !linkedIsArray) {\n          partialRecords = Array.isArray(linked[field]) ?\n            linked[field] : [ linked[field] ]\n\n          for (m = 0, n = partialRecords.length; m < n; m++) {\n            partialRecord = partialRecords[m]\n\n            if (partialRecord[inverseField] === update[primaryKey])\n              continue\n\n            removeId(partialRecord[primaryKey],\n              getUpdate(\n                type, partialRecord[inverseField],\n                relatedUpdates, idCache),\n              field, isArray)\n          }\n        }\n      }\n    }\n\n    return Promise.all(map(Object.keys(relatedUpdates), function (type) {\n      return relatedUpdates[type].length ?\n        transaction.update(type, relatedUpdates[type], meta) :\n        null\n    }))\n  })\n\n  .then(function () {\n    return transaction.endTransaction()\n  })\n\n  // This makes sure to call `endTransaction` before re-throwing the error.\n  .catch(function (error) {\n    if (transaction) transaction.endTransaction(error)\n    throw error\n  })\n\n  .then(function () {\n    var eventData = {}, linkedType\n\n    eventData[updateMethod] = {}\n    eventData[updateMethod][type] = hookedUpdates\n\n    for (linkedType in relatedUpdates) {\n      if (!relatedUpdates[linkedType].length) continue\n\n      if (linkedType !== type)\n        eventData[updateMethod][linkedType] = relatedUpdates[linkedType]\n\n      // Get the union of update IDs.\n      else eventData[updateMethod][type] =\n        eventData[updateMethod][type].concat(relatedUpdates[type])\n    }\n\n    // Summarize changes during the lifecycle of the request.\n    self.emit(changeEvent, eventData)\n\n    return context\n  })\n}\n\n\n// Validate updates.\nfunction validateUpdates (updates, meta) {\n  var language = meta.language\n  var i, j, update\n\n  if (!updates || !updates.length)\n    throw new BadRequestError(\n      message('UpdateRecordsInvalid', language))\n\n  for (i = 0, j = updates.length; i < j; i++) {\n    update = updates[i]\n    if (!update[primaryKey])\n      throw new BadRequestError(\n        message('UpdateRecordMissingID', language))\n  }\n}\n\n\nfunction dropFields (update, fields) {\n  var field\n\n  for (field in update.replace)\n    if (!fields.hasOwnProperty(field)) delete update.replace[field]\n\n  for (field in update.pull)\n    if (!fields.hasOwnProperty(field)) delete update.pull[field]\n\n  for (field in update.push)\n    if (!fields.hasOwnProperty(field)) delete update.push[field]\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/dispatch/find.js":"'use strict'\n\n/**\n * Fetch the primary records. This mutates `context.response`\n * for the next method.\n *\n * @return {Promise}\n */\nmodule.exports = function (context) {\n  var adapter = this.adapter\n  var request = context.request\n  var type = request.type\n  var ids = request.ids\n  var options = request.options\n  var meta = request.meta\n\n  if (!type) return context\n\n  return adapter.find(type, ids, options, meta)\n  .then(function (records) {\n    Object.defineProperty(context.response, 'records', {\n      configurable: true,\n      value: records\n    })\n\n    return context\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/dispatch/include.js":"'use strict'\n\nvar map = require('../common/array/map')\nvar find = require('../common/array/find')\nvar reduce = require('../common/array/reduce')\n\nvar errors = require('../common/errors')\nvar BadRequestError = errors.BadRequestError\n\nvar keys = require('../common/keys')\nvar primaryKey = keys.primary\nvar linkKey = keys.link\n\n\n/**\n * Fetch included records. This mutates `context`.response`\n * for the next method.\n *\n * @return {Promise}\n */\nmodule.exports = function include (context) {\n  var request = context.request\n  var type = request.type\n  var ids = request.ids || []\n  var include = request.include\n  var meta = request.meta\n  var response = context.response\n  var records = response.records\n  var recordTypes = this.recordTypes\n  var adapter = this.adapter\n  var i, j, record, id\n\n  // This cache is used to keep unique IDs per type.\n  var idCache = {}\n  idCache[type] = {}\n  for (i = 0, j = ids.length; i < j; i++)\n    idCache[type][ids[i]] = true\n\n  if (!type || !include || !records) return context\n\n  // It's necessary to iterate over primary records if no IDs were\n  // provided initially.\n  if (ids && !ids.length)\n    for (i = 0, j = records.length; i < j; i++) {\n      record = records[i]\n      id = record[primaryKey]\n      if (!idCache[type][id]) idCache[type][id] = true\n    }\n\n  return Promise.all(map(include, function (fields) {\n    return new Promise(function (resolve, reject) {\n      var currentType = type\n      var currentIds = []\n      var currentCache, currentOptions, currentField, includeOptions\n\n      if (typeof fields[fields.length - 1] === 'object') {\n        includeOptions = fields[fields.length - 1]\n\n        // Clone the fields array without options.\n        fields = fields.slice(0, -1)\n      }\n\n      // Ensure that the first level field is in the record.\n      return Promise.all(map(records, function (record) {\n        var options\n\n        if (!record.hasOwnProperty(fields[0])) {\n          options = { fields: {} }\n          options.fields[fields[0]] = true\n\n          return adapter.find(type, [ record[primaryKey] ], options, meta)\n          .then(function (records) { return records[0] })\n        }\n\n        return record\n      }))\n\n      .then(function (records) {\n        // `cursor` refers to the current collection of records.\n        return reduce(fields, function (records, field, index) {\n          return records.then(function (cursor) {\n            currentField = recordTypes[currentType][field]\n\n            if (!currentType || !currentField) return []\n            if (!(linkKey in currentField)) throw new BadRequestError(\n              'The field \"' + field + '\" does not define a link.')\n\n            currentCache = {}\n            currentType = currentField[linkKey]\n            currentIds = reduce(cursor, function (ids, record) {\n              var linkedIds = Array.isArray(record[field]) ?\n                record[field] : [ record[field] ]\n              var i, j, id\n\n              for (i = 0, j = linkedIds.length; i < j; i++) {\n                id = linkedIds[i]\n                if (id && !currentCache[id]) {\n                  currentCache[id] = true\n                  ids.push(id)\n                }\n              }\n\n              return ids\n            }, [])\n\n            if (index === fields.length - 1)\n              currentOptions = includeOptions\n            else {\n              currentOptions = { fields: {} }\n              currentOptions.fields[fields[index + 1]] = true\n            }\n\n            return currentIds.length ?\n              adapter.find(currentType, currentIds, currentOptions, meta) :\n              []\n          })\n        }, Promise.resolve(records))\n      })\n\n      .then(function (records) {\n        return resolve({\n          type: currentType,\n          ids: currentIds,\n          records: records\n        })\n      }, function (error) {\n        return reject(error)\n      })\n    })\n  }))\n\n  .then(function (containers) {\n    var include = reduce(containers, function (include, container) {\n      var i, j, id, record\n\n      if (!container.ids.length) return include\n\n      if (!include[container.type])\n        include[container.type] = []\n\n      // Only include unique IDs per type.\n      if (!idCache[container.type])\n        idCache[container.type] = {}\n\n      for (i = 0, j = container.ids.length; i < j; i++) {\n        id = container.ids[i]\n\n        if (idCache[container.type][id]) continue\n\n        record = find(container.records, matchId(id))\n\n        if (record) {\n          idCache[container.type][id] = true\n          include[container.type].push(record)\n        }\n      }\n\n      // If nothing so far, delete the type from include.\n      if (!include[container.type].length)\n        delete include[container.type]\n\n      return include\n    }, {})\n\n    if (Object.keys(include).length)\n      Object.defineProperty(context.response, 'include', {\n        configurable: true,\n        value: include\n      })\n\n    return context\n  })\n}\n\n\nfunction matchId (id) {\n  return function (record) {\n    return record[primaryKey] === id\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/dispatch/end.js":"'use strict'\n\nvar map = require('../common/array/map')\n\n\n/**\n * Apply `output` hook per record, this mutates `context.response`.\n *\n * @return {Promise}\n */\nmodule.exports = function (context) {\n  var hooks = this.hooks\n  var request = context.request\n  var response = context.response\n  var type = request.type\n  var hook = hooks[type]\n  var records = response.records\n  var include = response.include\n\n  // Delete temporary keys.\n  delete response.records\n  delete response.include\n\n  // Delete this key as well, since the transaction should already be ended\n  // at this point.\n  delete context.transaction\n\n  // Run hooks on primary type.\n  return (records ? Promise.all(map(records, function (record) {\n    return Promise.resolve(typeof hook[1] === 'function' ?\n      hook[1](context, record) : record)\n  }))\n\n  .then(function (updatedRecords) {\n    var includeTypes\n    var i, j\n\n    for (i = 0, j = updatedRecords.length; i < j; i++)\n      if (updatedRecords[i]) records[i] = updatedRecords[i]\n\n    if (!include) return void 0\n\n    // The order of the keys and their corresponding indices matter.\n    includeTypes = Object.keys(include)\n\n    // Run output hooks per include type.\n    return Promise.all(map(includeTypes, function (includeType) {\n      return Promise.all(map(include[includeType], function (record) {\n        return Promise.resolve(\n          typeof hooks[includeType][1] === 'function' ?\n            hooks[includeType][1](context, record) : record)\n      }))\n    }))\n\n    .then(function (types) {\n      var i, j, k, l\n\n      // Assign results of output hooks on includes.\n      for (i = 0, j = types.length; i < j; i++)\n        for (k = 0, l = types[i].length; k < l; k++)\n          if (types[i][k]) include[includeTypes[i]][k] = types[i][k]\n    })\n  }) : Promise.resolve())\n\n  .then(function () {\n    context.response.payload = {\n      records: records\n    }\n\n    if (include) context.response.payload.include = include\n\n    // Expose the \"count\" property so that it is serializable.\n    if (records && 'count' in records)\n      context.response.payload.count = records.count\n\n    return context\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/global.js":"'use strict'\n\nwindow.fortune = require('./')\n","/home/travis/build/npmtest/node-npmtest-fortune/node_modules/fortune/lib/header.js":"'use strict'\n\nvar pkg = require('../package.json')\n\nprocess.stdout.write([\n  '/*!',\n  ' * Fortune.js',\n  ' * Version ' + pkg.version,\n  ' * ' + pkg.license + ' License',\n  ' * ' + pkg.homepage,\n  ' */', ''\n].join('\\n'))\n"}